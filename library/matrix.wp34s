/* Matrix creation routines.  The first entry point creates an identity
 * matrix.  The second creates a zero matrix.  Both of these routines do
 * not change the stack at all.  They both replace L however.  They also
 * clear flag C on exit.
 */

/* Create an identity matrix */
m_ident::		LBL'M.1'
			SF C
			JMP m_init_1
/* Create a zero matrix */
m_zero::		LBL'M.0'
			CF C
m_init_1::		ABS
			M.ALL
m_init_2::			STO[->]X
				STO-[->]X
				ISG X
				JMP m_init_2
m_init_3::		x[<->] L
			FC?C C
			RTN
			M.DIAG
m_init_4::			INC[->]X
				ISG X
				JMP m_init_4
			JMP m_init_3

/* Trace of a matrix.
 * Uses stack.
 * Uses flag C.
 */
 			/* Sum of absolute values of diagonal elements */
 			LBL'ATR'
			SF C
			JMP m_trace_common

			/* Sum of diagonal elements */
			LBL'TR'
			CF C
m_trace_common::	ABS
			M.DIAG
			iC 0
m_trace_loop::		RCL[->]Y
			FS? C
			ABS
			+
			ISG Y
			JMP m_trace_loop
			JMP drop_y

/* Matrix addition and subtraction.
 * Matrix descriptors in X and Y.
 * Resulting matrix descriptor returned in X.
 * Uses one stack level.
 */
			LBL'M-'	/* X = X - Y */
			iC 1
			+/-
			JMP m_add_sub_common

			LBL'M+'	/* X = X + Y */
			iC 1
m_add_sub_common::	x[<->] Z
			x[<->]y
			M.+[times]
			RTN

/* Matrix Transpose multiply
 */
			LBL'M`[times]'
			[cmplx]x[<->]y
			M.TRN
			[cmplx]x[<->]y
			M.[times]
			RTN


/* Maxtrix norm.
 * Uses stack.
 */
			LBL'MNM'
			M.ALL
			iC 0
m_norm_loop::		RCL[->]Y
			x[^2]
			+
			ISG Y
			JMP m_norm_loop
			[sqrt]
			JMP drop_y

/* Maximum & minimum elements in a matrix
 * Uses stack.
 */
			LBL'M[^]'
			M.ALL
			RCL[->]X
m_max_loop::		RCL[^][->]Y
			ISG Y
			JMP m_max_loop
			JMP drop_y

			LBL'M[v]'
			M.ALL
			RCL[->]X
m_min_loop::		RCL[v][->]Y
			ISG Y
			JMP m_min_loop
			/*JMP drop_y*/

drop_y::		x[<->]y
			DROP
			RTN

