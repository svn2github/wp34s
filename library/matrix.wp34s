/* Matrix creation routines.  The first entry point creates an identity
 * matrix.  The second creates a zero matrix.  Both of these routines do
 * not change the stack at all.  They both replace L however.  They also
 * clear flag C on exit.
 */

/* Create an identity matrix */
m_ident::		LBL'M.1'
			SF C
			JMP m_init_1
/* Create a zero matrix */
m_zero::		LBL'M.0'
			CF C
m_init_1::		ABS
			M.ALL
m_init_2::			STO[->]X
				STO-[->]X
				ISG X
				JMP m_init_2
m_init_3::		x[<->] L
			FC?C C
			RTN
			M.DIAG
m_init_4::			INC[->]X
				ISG X
				JMP m_init_4
			JMP m_init_3

/* Trace of a matrix.
 * Uses stack.
 * Uses flag C.
 */
 			/* Sum of absolute values of diagonal elements */
 			LBL'ATR'
			SF C
			JMP m_trace_common

			/* Sum of diagonal elements */
			LBL'TR'
			CF C
m_trace_common::	ABS
			M.DIAG
			iC 0
m_trace_loop::		RCL[->]Y
			FS? C
			ABS
			+
			ISG Y
			JMP m_trace_loop
			JMP drop_y

/* Matrix addition and subtraction.
 * Matrix descriptors in X and Y.
 * Resulting matrix descriptor returned in X.
 * Uses one stack level.
 */
			LBL'M-'	/* X = X - Y */
			iC 1
			+/-
			JMP m_add_sub_common

			LBL'M+'	/* X = X + Y */
			iC 1
m_add_sub_common::	x[<->] Z
			x[<->]y
			M.+[times]
			RTN

/* Scalar multiply
 */
			LBL'M.y'
			ABS
			M.ALL
			x[<->]y
m_scalar_mult::		STO[times][->]Y
			ISG Y
			JMP m_scalar_mult
			[cmplx]DROP
			RTN

/* Maxtrix norm.
 * Uses stack.
 */
			LBL'FNM'
			ABS
			+/-
			M.ALL
			[SIGMA] m_frob_sum
			[sqrt]
			RTN
m_frob_sum::		x[^2]
			RTN


/* Maxtrix row and column norms.
 * Uses stack + A, B, C and D.
 */
			LBL'RNM'
			SF C
			JMP m_norm_common

			LBL'CMN'
			CF C
m_norm_common::		STOM B			/* save mode settings */
			SSIZE4
			ABS
			+/-
			STO C			/* save matrix descriptor */
			iC 0
			STO A
			iC 1
			RCL Z
			FS? C
			M.COL
			FC? C
			M.ROW
			STO D
m_norm_loop::		[cmplx]RCL C
			M.IJ
			FS? C
			x[<->]y
			DROP
			RCL C
			FS? C
			M.ROW
			FC? C
			M.COL
			[SIGMA] m_norm_sum
			STO[^] A
			DSL D
			JMP m_norm_loop
			RCL A
			RCLM B
			CF C
			RTN

m_norm_sum::		RCL[->]X
			ABS
			RTN

/* Find a specified element in a matrix
 */
 			LBL'MFD'
			ABS
			M.ALL
			x[<->]y
m_find_loop::		x=?[->]Y
			JMP m_found
			ISG Y
			JMP m_find_loop
m_found::		DROP
			RTN

/* Maximum & minimum elements in a matrix
 * Uses stack.
 */
			LBL'M[^]'
			M.ALL
			RCL[->]X
m_max_loop::		RCL[^][->]Y
			ISG Y
			JMP m_max_loop
			JMP drop_y

			LBL'M[v]'
			M.ALL
			RCL[->]X
m_min_loop::		RCL[v][->]Y
			ISG Y
			JMP m_min_loop
			/*JMP drop_y*/

drop_y::		x[<->]y
			DROP
			RTN

