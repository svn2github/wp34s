Introduce:
		unsigned int find_program_start(unsigned int pc)
		unsigned int find_program_end(unsigned int pc)
	the second might not be worth separating out however.


Modify:
		inc
		dec
		incpc
		decpc

	to take an extra argument that indicates if END is a terminal
	instruction or not.  Consider creating sister routines or
	wrappering a common routine for this instead of using an
	extra argument.

	Further thought here: make inc() and dec() wrappers that call a routine
	that takes an extra argument (do_inc and do_dec).  The extra argument
	specifies if END is terminal or not.  There won't be many cases of
	do_inc and do_dec needing to be called directly -- only global label
	searches and the global label browser.

	incpc and decpc need no such wrapping -- they are only used in places
	where END is important.


Modify:
	find_section_bounds needs to figure out how to work with ENDs.


Modify:
	user_pc needs to reworked to start from the start of the current program
	not the current region.

DONE:
	find_opcode / find_lbl to differentiate local labels from
	alpha labels with respects to the wraping machanics.

Modify:
	CAT browser mustn't wrap.
	CAT browser shows ENDs.

	SKIP, BACK wrap on END.
	SST, BST wrap on END.
	conditional tests wrap on END.

	GTO .. must go to the end of RAM program memory & optionally insert END.
	More navigation commands are needed: GTO.up GTO.down for skipping
	to the begin of the current or next program. GTO.'ABC' to go to a label.

	CLP clears current program only. The multi line delete becomes obsolete.

	Program CRC must be for the current program only (on SHOW).


Consider:
	reserving a pair of memory locations to store the current
	program start and finish.  Update these when/if required.
	Zero them on procedure call or RTN but only if the called
	or the return address lie outside the current range.

	ProgBegin, ProgEnd, update_begin_end() -- partially done
	Move ProgBegin/ProgEnd into volatile RAM and recalculate as required??
	They'll only be recalculated on global XEQ or after a power off.
	The first is unavoidable.  The second means a user interaction so a
	performance hit then is minimal.  Also, wrapper this into get_start and
	get_end calls that do the update is required -- these calls should also
	handle xrom and library regions and might simplify other code.

	numeric label search optimisation once the end is reached...
		search backwards from the starting address and remember the
		last matching label.  Once the beginning of the program is
		reached, return the last matched address.

	also consider caching numeric labels in a table in volatile memory to
	make branches to labels very fast. Get rid of duplicate local labels 
	then.


Subsequently:
	a program in flash filing system.
	a program in RAM filing system that escapes the 510 step limitation.
