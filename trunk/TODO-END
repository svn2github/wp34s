Introduce:
		unsigned int find_program_start(unsigned int pc)
		unsigned int find_program_end(unsigned int pc)
	the second might not be worth separating out however.

DONE (instead):
	update_program_bounds(force) to set pointers PorgBegin, ProgEnd.

Modify:
		inc
		dec
		incpc
		decpc

	to take an extra argument that indicates if END is a terminal
	instruction or not.  Consider creating sister routines or
	wrappering a common routine for this instead of using an
	extra argument.

	Further thought here: make inc() and dec() wrappers that call a routine
	that takes an extra argument (do_inc and do_dec).  The extra argument
	specifies if END is terminal or not.  There won't be many cases of
	do_inc and do_dec needing to be called directly -- only global label
	searches and the global label browser.

	incpc and decpc need no such wrapping -- they are only used in places
	where END is important.

DONE:
	do_inc(), do_dec() argument. dec/inc obey porgram bounds. 

Modify:
	find_section_bounds needs to figure out how to work with ENDs.
DONE:	
	find_section_bounds has a parameter to obey the bounds or not.
	In program entry mode, all program memory is freely addressable (no bounds).

Modify:
	user_pc needs to reworked to start from the start of the current program
	not the current region.
	
DONE:
	find_opcode / find_lbl to differentiate local labels from
	alpha labels with respects to the wraping machanics.
	This seems to work! The code has been simplified.

Modify:
	CAT browser mustn't wrap.
	CAT browser shows ENDs.
	This needs to be investigated

	SKIP, BACK wrap on END.
	SST, BST wrap on END.
	conditional tests wrap on END.
	This should work because incpc and decpc are modified.

	GTO .. must go to the end of RAM program memory & optionally insert END.
	More navigation commands are needed: GTO.up GTO.down for skipping
	to the begin of the current or next program. GTO.'ABC' to go to a label.
	
	CLP clears current program only. The multi line delete becomes obsolete.

	Program CRC must be for the current program only (on SHOW).

DONE:
	GTO.. inserts END if needed.
	GTO.up jumps to the beginning of the current program and then backwards to
	the previous program.
	GTO.down jumps to the next program.

Consider:
	reserving a pair of memory locations to store the current
	program start and finish.  Update these when/if required.
	Zero them on procedure call or RTN but only if the called
	or the return address lie outside the current range.

DONE:
	ProgBegin, ProgEnd, update_begin_end()

Consider:
	Move ProgBegin/ProgEnd into volatile RAM and recalculate as required??
	They'll only be recalculated on global XEQ or after a power off.
	The first is unavoidable.  The second means a user interaction so a
	performance hit then is minimal.  Also, wrapper this into get_start and
	get_end calls that do the update is required -- these calls should also
	handle xrom and library regions and might simplify other code.

	numeric label search optimisation once the end is reached...
		search backwards from the starting address and remember the
		last matching label.  Once the beginning of the program is
		reached, return the last matched address.

	also consider caching numeric labels in a table in volatile memory to
	make branches to labels very fast. Get rid of duplicate local labels 
	then.


Subsequently:
	a program in flash filing system.
	a program in RAM filing system that escapes the 510 step limitation.
