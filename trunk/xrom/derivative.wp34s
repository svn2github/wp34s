/* The exposed functions in this file don't use the normal prologue/epilogue
 * and do not operate in double precision.  They call back to user code and
 * manage the stack, input, output and locals themselves.
 *
 * Changes to this will likely cause breakage.
 */

/**************************************************************************/
/* Numerical differentiation
 * Register use:
 * 0	E3
 * 1	E2
 * 2	E1
 * 3	X
 * 4	H
 */

#define E3	.00
#define E2	.01
#define E1	.02
#define X	.03
#define H	.04


/*
 * Flag use:
 * 0	second derivative
 */

#define FL_2ND		.00

		XLBL"2DERIV"			/* Entry: SECOND DERIVATIVE */
			XEQ entry
			LocR 04				/* Registers .00 to .04 */
			SPEC?
				JMP deriv_bad_input
			SF FL_2ND
			XEQ deriv_default_h
			1
			XEQ deriv_eval_func		/* f(x+h) + f(x-h)*/
				JMP deriv_bad_input
			1
			6
			[times]
			STO E2				/* order four estimate*/
			4
			2
			EEX
			3
			RCL[times] E3
			STO E1				/* order ten estimate*/
			0
			XEQ deriv_eval_func		/* f(x)*/
				JMP deriv_bad_input
			3
			0
			[times]
			STO- E2
			7
			3
			7
			6
			6
			RCL[times] E3
			STO- E1

			2
			XEQ deriv_eval_func		/* f(x+2h) + f(x-2h)*/
				JMP deriv_bad_input
			STO- E2
			6
			EEX
			3
			[times]
			STO- E1

			3
			XEQ deriv_eval_func		/* f(x+3h) + f(x-3h)*/
				JMP deriv2_4point
			EEX
			3
			[times]
			STO+ E1

			4
			XEQ deriv_eval_func		/* f(x+4h) + f(x-4h)*/
				JMP deriv2_4point
			1
			2
			5
			[times]
			STO- E1

			5
			XEQ deriv_eval_func		/* f(x+5h) + f(x-5h)*/
				JMP deriv2_4point
			8
			[times]
			RCL+ E1
			2
			5
			2
			SDL 02				/* * 100 = 25200*/
			RCL[times] H
			RCL[times] H
			/
			JMP deriv_return

deriv_bad_input::	Num NaN
			JMP deriv_return

deriv2_4point::		1
			2
			RCL[times] H
			RCL[times] H
			1/x
			STO[times] E2

deriv_6point::		RCL E2
			JMP deriv_return


		XLBL"DERIV"				/* Entry: DERIVATIVE */
			XEQ entry
			LocR 04				/* Registers .00 to .04 */
			SPEC?
				JMP deriv_bad_input
			CF FL_2ND
			XEQ deriv_default_h
			1
			XEQ deriv_eval_func		/* f(x+h) - f(x-h)*/
				JMP deriv_bad_input
			STO E2

			2
			XEQ deriv_eval_func		/* f(x+2h) - f(x-2h)*/
				JMP deriv_bad_input
			STO E1

			/* At this point we can do a four point estimate if something goes awry */
			3
			XEQ deriv_eval_func		/* f(x+3h)-f(x-3h)*/
				JMP deriv_4point

			/* At this point we can do the six point estimate - calculate it now */
			4
			5
			RCL[times] E2
			9
			RCL[times] E1
			-
			+
			6
			0
			RCL[times] H
			/
			x[<->] E2			/* Six point stimate in E2 & start ten point estimate*/
			2
			1
			SDL 02				/* * 100 = 2100*/
			[times]
			6
			SDL 02				/* * 100 = 600*/
			RCL[times] E1
			-
			1
			5
			0
			RCL[times] E3
			+				/* Ten point estimate to end up in E1*/

			STO E1
			4
			XEQ deriv_eval_func		/* f(x+4h) - f(x-4h)*/
				JMP deriv_6point
			2
			5
			[times]
			STO- E1

			5
			XEQ deriv_eval_func		/* f(x+5h) - f(x-5h)*/
				JMP deriv_6point
			RCL+ E3
			RCL+ E1
			2
			5
			2
			0
			RCL[times] H
			/
			JMP deriv_return

			/* Eval f(X + k h) k on stack */
deriv_eval_func::	STO E3
			RCL[times] H
			RCL+ X
			FILL
			XEQUSR				/* f(x + k h)*/
			POPUSR
			SPEC?
				RTN
			x[<->] E3
			x=0?
				JMP deriv_skip_midpoint
			+/-
			RCL[times] H
			RCL+ X
			FILL
			XEQUSR				/* f(x - k h)*/
			POPUSR
			SPEC?
				RTN
			FS? FL_2ND
			+/-
			STO- E3

deriv_skip_midpoint::	RCL E3
			RTN+1

deriv_4point::		8
			RCL[times] E2
			RCL- E1
			1
			2
			RCL[times] H
			/

deriv_return::		STO L
			iC 0
			FILL
			RCL X
			x[<->] L
			RTN
/*
 *  This part contains double word instructions and must not be located between a
 *  JMP and its label because in XROM, BACK and SKIP are computed instead of 
 *  walking the PC. This would fail with a long instruction in between.
 */
deriv_default_h::	STO X
			FILL
			LBL?'[delta]X'
				JMP deltaX
			iC 1
			SDR 01				/* default h = 0.1 */
			STO H
			RTN

deltaX::		XEQ'[delta]X'
			STO H
			RTN
