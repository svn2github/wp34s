/* This file contains the code for the xrom commands that take label arguments
 * and call back into user space.  These are all different to the remainder
 * of the commands in that they perform their own stack management and never
 * replace the user stack with the private xrom stack.
 */

/* Solve code.
 *
 * On entry the stack looks like:
 *	Y	Guess a
 *	X	Guess b
 *
 * On return the stack looks like:
 *	L	0
 *
 *	T	0
 *	Z	f(X)
 *	Y	previous root estimate
 *	X	root estimate
 *
 * Register use:
 * 0	a	lower bound
 * 1	b	upper bound
 * 2	c	new guess
 * 3	f(a)
 * 4	f(b)
 */
		XLBL"SOLVE"			/* Entry: SOLVE */
			XEQ entry
			LocR 04			/* Need 5 registers and flags */
			x[approx]? Y
				INC Y
			x[approx]? Y
				SDR 01
			x>? Y
				x[<->] Y
			[cmplx]STO .00
			FILL
			XEQUSR
			POPUSR
			STO .03
			x[approx]0?
				JMP slv_initial1_perfect
			RCL .01
			FILL
			XEQUSR
			POPUSR
			STO .04
			x[approx]0?
				JMP slv_initial2_perfect
			SLVI
			RCL .02

slv_loop::		FILL
			XEQUSR
			POPUSR
			FILL
			x[approx]0?
				JMP slv_success
			SLVS
			x[!=]0?			/* Check for failure to complete*/
				JMP slv_failed
			RCL .02
			x[approx]? .00
				JMP slv_fin
			x[approx]? .01
				JMP slv_fin
			JMP slv_loop

			/* Solver estimates converged */
slv_fin::		iC 0
			STO L
			RCL T
			RCL .01
			RCL .02
			RTN

slv_failed::		RCL .03
			ABS
			RCL .04
			ABS
			x<? Y
				JMP slv_fail_BltA
			RCL T			/* Return the better estimate being A */
			STO L
			iC 0
			x[<->] Y
			RCL .00
			RCL .02
			JMP slv_fail_common

slv_fail_BltA::		RCL T
			STO L
			iC 0
			x[<->] Y
			RCL .01
			RCL .02

slv_fail_common::	TOP?
				ERR 20
			RTN+1

slv_success::		iC 0
			STO L
			RCL Z
			RCL .01
			RCL .02
			RTN

slv_initial2_perfect::	RCL .04
			RCL .01
			JMP slv_initial_common

slv_initial1_perfect::	RCL .03
			RCL .00

slv_initial_common::	RCL X
			iC 0
			STO L
			[cmplx]x[<->] Z
			RTN


/* Integrate code
 * We're using a Gauss-Kronrod quadrature with 10 Guass points
 * and 21 Kronrod points.  We calculate the Guass quadrature
 * first so we can give an estimate if an error occurs during the
 * extra evaluations of the Kronrod quadrature.
 *
 * On entry the stack looks like:
 *	Y	lower limit
 *	X	upper limit
 *
 * On return the stack looks like:
 *	L	integral (Gauss)
 *	I	unchanged
 *
 *	T	lower limit (Y on input)
 *	Z	upper limit (X on input)
 *	Y	error estimate (Gauss - Kronrod)
 *	X	integral (Kronrod)
 *
 * Register use:
 * 0	half interval length
 * 1	interval midpoint
 * 2	Gauss sum
 * 3	Kronrod sum
 * 4	Index
 */

int_bad_range::		XEQ int_restore_limits
			Num NaN
			ENTER[^]
			STO L
			RTN

int_zero_interval::	XEQ int_restore_limits
			iC 0
			ENTER[^]
			STO L
			RTN


		XLBL"INTEGRATE"			/* Entry: INTEGRATE */
			XEQ entry
			LocR 04				/* Need registers .00 to .04 */
			SPEC?
				JMP int_bad_range
			x[<->] Y
			SPEC?
				JMP int_bad_range
			x=? Y				/* Check if range is zero*/
				JMP int_zero_interval
			x[<->] Y

			/* Compute (x-y)/2 and (x+y)/2 */
			[cmplx]ENTER
			+
			2
			/
			x[<->] Z
			-
			2
			/
			[cmplx]STO .00			/* Also stores the midpoint */

			/* Initialise the summations */
			iC 0
			STO .02
			STO .03

			/* Loop through the common points */
			iC 15.02903
			STO .04

			/* Sum Gauss and Kronrod common points */
int_gkloop::		XEQ int_first_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range
			XEQ int_gauss
			XEQ int_second_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range
			XEQ int_gauss
			ISG .04
				JMP int_gkloop

			/* Evaluate at midpoint for the Kronrod estimate */
			RCL .00
			STO[times] .02
			RCL .01
			FILL
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range2
			iC 0.14944555
			[times]
			STO+ .03

			/* Now loop through the Kronrod points */
			iC 5.01402
			STO .04

			/* Sum Kronrod only points */
int_kloop::		XEQ int_first_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range2
			XEQ int_kronrod
			XEQ int_second_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range2
			XEQ int_kronrod
			ISG .04
				JMP int_kloop

			RCL .00
			STO[times] .03

			/* Set up the stack for our output */
			XEQ int_restore_limits
			RCL .03
			RCL- .02				/* err, l, u, ?, G*/
			RCL .03				/* K, err, l, u, G*/
			RTN

			/* Calculate the first point from the xi */
int_first_point::	iC[->].04
			RCL[times] .00
			RCL+ .01
			FILL
			RTN

			/* Calculate the second point from the xi */
int_second_point::	RCL .01
			iC[->].04
			RCL[times] .00
			-
			FILL
			RTN

			/* Do a Kronrod accumulation, f(xi) in X */
int_kronrod::		RCL .04				/* i, f, ?, ?*/
			INC X				/* i+1, f, ?, ?*/
			iC[->]X				/* ki, i+1, f, ?*/
			STO L
			RCL Z				/* f, ki, i+1, f*/
			FILL				/* f, f, f, f*/
			RCL[times] L			/* ki*f, f, f, f*/
			STO+ .03
			RTN

			/* Gauus Kronrod accumulation, f(xi) in X */
int_gauss::		RCL .04		
			INC X				/* I+1, f, ?, ?*/
			RCL Y				/* f, I+1, f, ?*/
			RCL X				/* f, f, I+1, f*/
			iC[->]Z				/* gi, f, f, I+1*/
			INC T				/* gi, f, f, I+2*/
			[times]				/* gi*f, f, I+2, I+2*/
			STO+ .02
			DROP				/* f, I+2, I+2, I+2*/
			iC[->]Z				/* ki, f, I+2, I+2*/
			[times]				/* ki*f, I+2, I+2, I+2*/
			STO+ .03
			RTN

			/* A value is NaN after the Gauss estimate */
int_bad_range2:: 	XEQ int_restore_limits
			Num NaN
			RCL .02
			STO L
			RTN

int_restore_limits::	RCL .01
			RCL- .00
			RCL .01
			RCL+ .00		/* l, u*/
			RTN


/**************************************************************************/
/* Sigma and products
 * Register use:
 * 0	I
 * 1	product/sum
 * 2	carry for sum
 * 3	saved I
 */
		XLBL"SIGMA"				/* Entry: SUMMATION */
			XEQ entry
			LocR 03				/* Registers .00 to .03 */
			STO .03				/* Save for LastX*/
			SPEC?
				JMP sum_product_nan
			STO .00
			IP				/* First function call is separate*/
			FILL				/* to avoid Kahan summing from zero*/
			XEQUSR				/* six extra instructions save nine*/
			POPUSR
			SPEC?				/* from executing*/
				JMP sum_product_nan
			STO .01
			iC 0
			STO .02
			JMP sum_entry

sum_loop::		RCL .00
			IP
			FILL
			XEQUSR
			POPUSR
			SPEC?
				JMP sum_product_nan
			RCL- .02
			ENTER[^]
			RCL+ .01
			ENTER[^]
			RCL- .01
			RCL- Z
			x[<->] Y
			[cmplx]STO .01

sum_entry::		DSL .00
				JMP sum_loop
			JMP sum_product_okay


		XLBL"PRODUCT"				/* Entry: PRODUCT */
			XEQ entry
			LocR 03				/* Registers .00 to .03 */
			STO .03
			SPEC?
				JMP sum_product_nan
			STO .00
			IP				/* First function call is separate*/
			FILL				/* to avoid a multiply*/
			XEQUSR
			POPUSR
			SPEC?
				JMP sum_product_nan
			STO .01
			JMP product_entry

product_loop::		RCL .00
			IP
			FILL
			XEQUSR
			POPUSR
			SPEC?
				JMP sum_product_nan
			STO[times] .01
product_entry::		DSL .00
				JMP product_loop

sum_product_okay::	RCL .03
			STO L
			iC 0
			FILL
			RCL .01
			RTN

sum_product_nan::	Num NaN
			STO .01
			JMP sum_product_okay



