/* Solve code.
 *
 * On entry the stack looks like:
 *	Y	Guess a
 *	X	Guess b
 *
 * On return the stack looks like:
 *	L	0
 *
 *	T	0
 *	Z	f(X)
 *	Y	previous root estimate
 *	X	root estimate
 *
 * Register use:
 * 0	a	lower bound
 * 1	b	upper bound
 * 2	c	new guess
 * 3	f(a)
 * 4	f(b)
 */
		LBL ENTRY_SOLVE			/* Entry: SOLVE */
			XEQ entry
			LocR 04			/* Need 5 registers and flags */
			x[approx]? Y
				INC Y
			x[approx]? Y
				SDR 01
			x>? Y
				x[<->] Y
			[cmplx]STO .00
			FILL
			XEQUSR
			POPUSR
			STO .03
			x[approx]0?
				JMP slv_initial1_perfect
			RCL .01
			FILL
			XEQUSR
			POPUSR
			STO .04
			x[approx]0?
				JMP slv_initial2_perfect
			SLVI
			RCL .02

slv_loop::		FILL
			XEQUSR
			POPUSR
			FILL
			x[approx]0?
				JMP slv_success
			SLVS
			x[!=]0?			/* Check for failure to complete*/
				JMP slv_failed
			RCL .02
			x[approx]? .00
				JMP slv_fin
			x[approx]? .01
				JMP slv_fin
			JMP slv_loop

			/* Solver estimates converged */
slv_fin::		iC 0
			STO L
			RCL T
			RCL .01
			RCL .02
			RTN

slv_failed::		RCL .03
			ABS
			RCL .04
			ABS
			x<? Y
				JMP slv_fail_BltA
			RCL T			/* Return the better estimate being A */
			STO L
			iC 0
			x[<->] Y
			RCL .00
			RCL .02
			JMP slv_fail_common

slv_fail_BltA::		RCL T
			STO L
			iC 0
			x[<->] Y
			RCL .01
			RCL .02

slv_fail_common::	TOP?
				ERR 20
			RTN+1

slv_success::		iC 0
			STO L
			RCL Z
			RCL .01
			RCL .02
			RTN

slv_initial2_perfect::	RCL .04
			RCL .01
			JMP slv_initial_common

slv_initial1_perfect::	RCL .03
			RCL .00

slv_initial_common::	RCL X
			iC 0
			STO L
			[cmplx]x[<->] Z
			RTN


/* Integrate code
 * We're using a Gauss-Kronrod quadrature with 10 Guass points
 * and 21 Kronrod points.  We calculate the Guass quadrature
 * first so we can give an estimate if an error occurs during the
 * extra evaluations of the Kronrod quadrature.
 *
 * On entry the stack looks like:
 *	Y	lower limit
 *	X	upper limit
 *
 * On return the stack looks like:
 *	L	integral (Gauss)
 *	I	unchanged
 *
 *	T	lower limit (Y on input)
 *	Z	upper limit (X on input)
 *	Y	error estimate (Gauss - Kronrod)
 *	X	integral (Kronrod)
 *
 * Register use:
 * 0	half interval length
 * 1	interval midpoint
 * 2	Gauss sum
 * 3	Kronrod sum
 * 4	Index
 */

int_bad_range::		XEQ int_restore_limits
			Num NaN
			ENTER[^]
			STO L
			RTN

int_zero_interval::	XEQ int_restore_limits
			iC 0
			ENTER[^]
			STO L
			RTN


		LBL ENTRY_INTEGRATE			/* Entry: INTEGRATE */
			XEQ entry
			LocR 04				/* Need registers .00 to .04 */
			SPEC?
				JMP int_bad_range
			x[<->] Y
			SPEC?
				JMP int_bad_range
			x=? Y				/* Check if range is zero*/
				JMP int_zero_interval
			x[<->] Y

			/* Compute (x-y)/2 and (x+y)/2 */
			[cmplx]ENTER
			+
			2
			/
			x[<->] Z
			-
			2
			/
			[cmplx]STO .00			/* Also stores the midpoint */

			/* Initialise the summations */
			iC 0
			STO .02
			STO .03

			/* Loop through the common points */
			iC 15.02903
			STO .04

			/* Sum Gauss and Kronrod common points */
int_gkloop::		XEQ int_first_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range
			XEQ int_gauss
			XEQ int_second_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range
			XEQ int_gauss
			ISG .04
				JMP int_gkloop

			/* Evaluate at midpoint for the Kronrod estimate */
			RCL .00
			STO[times] .02
			RCL .01
			FILL
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range2
			iC 0.14944555
			[times]
			STO+ .03

			/* Now loop through the Kronrod points */
			iC 5.01402
			STO .04

			/* Sum Kronrod only points */
int_kloop::		XEQ int_first_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range2
			XEQ int_kronrod
			XEQ int_second_point
			XEQUSR
			POPUSR
			SPEC?
				JMP int_bad_range2
			XEQ int_kronrod
			ISG .04
				JMP int_kloop

			RCL .00
			STO[times] .03

			/* Set up the stack for our output */
			XEQ int_restore_limits
			RCL .03
			RCL- .02				/* err, l, u, ?, G*/
			RCL .03				/* K, err, l, u, G*/
			RTN

			/* Calculate the first point from the xi */
int_first_point::	iC[->].04
			RCL[times] .00
			RCL+ .01
			FILL
			RTN

			/* Calculate the second point from the xi */
int_second_point::	RCL .01
			iC[->].04
			RCL[times] .00
			-
			FILL
			RTN

			/* Do a Kronrod accumulation, f(xi) in X */
int_kronrod::		RCL .04				/* i, f, ?, ?*/
			INC X				/* i+1, f, ?, ?*/
			iC[->]X				/* ki, i+1, f, ?*/
			STO L
			RCL Z				/* f, ki, i+1, f*/
			FILL				/* f, f, f, f*/
			RCL[times] L			/* ki*f, f, f, f*/
			STO+ .03
			RTN

			/* Gauus Kronrod accumulation, f(xi) in X */
int_gauss::		RCL .04		
			INC X				/* I+1, f, ?, ?*/
			RCL Y				/* f, I+1, f, ?*/
			RCL X				/* f, f, I+1, f*/
			iC[->]Z				/* gi, f, f, I+1*/
			INC T				/* gi, f, f, I+2*/
			[times]				/* gi*f, f, I+2, I+2*/
			STO+ .02
			DROP				/* f, I+2, I+2, I+2*/
			iC[->]Z				/* ki, f, I+2, I+2*/
			[times]				/* ki*f, I+2, I+2, I+2*/
			STO+ .03
			RTN

			/* A value is NaN after the Gauss estimate */
int_bad_range2:: 	XEQ int_restore_limits
			Num NaN
			RCL .02
			STO L
			RTN

int_restore_limits::	RCL .01
			RCL- .00
			RCL .01
			RCL+ .00		/* l, u*/
			RTN


/**************************************************************************/
/* Sigma and products
 * Register use:
 * 0	I
 * 1	product/sum
 * 2	carry for sum
 * 3	saved I
 */
		LBL ENTRY_SIGMA				/* Entry: SUMMATION */
			XEQ entry
			LocR 03				/* Registers .00 to .03 */
			STO .03				/* Save for LastX*/
			SPEC?
				JMP sum_product_nan
			STO .00
			IP				/* First function call is separate*/
			FILL				/* to avoid Kahan summing from zero*/
			XEQUSR				/* six extra instructions save nine*/
			POPUSR
			SPEC?				/* from executing*/
				JMP sum_product_nan
			STO .01
			iC 0
			STO .02
			JMP sum_entry

sum_loop::		RCL .00
			IP
			FILL
			XEQUSR
			POPUSR
			SPEC?
				JMP sum_product_nan
			RCL- .02
			ENTER[^]
			RCL+ .01
			ENTER[^]
			RCL- .01
			RCL- Z
			x[<->] Y
			[cmplx]STO .01

sum_entry::		DSL .00
				JMP sum_loop
			JMP sum_product_okay


		LBL ENTRY_PI				/* Entry: PRODUCT */
			XEQ entry
			LocR 03				/* Registers .00 to .03 */
			STO .03
			SPEC?
				JMP sum_product_nan
			STO .00
			IP				/* First function call is separate*/
			FILL				/* to avoid a multiply*/
			XEQUSR
			POPUSR
			SPEC?
				JMP sum_product_nan
			STO .01
			JMP product_entry

product_loop::		RCL .00
			IP
			FILL
			XEQUSR
			POPUSR
			SPEC?
				JMP sum_product_nan
			STO[times] .01
product_entry::		DSL .00
				JMP product_loop

sum_product_okay::	RCL .03
			STO L
			iC 0
			FILL
			RCL .01
			RTN

sum_product_nan::	Num NaN
			STO .01
			JMP sum_product_okay

/**************************************************************************/
/* Numerical differentiation
 * Register use:
 * 0	E3
 * 1	E2
 * 2	E1
 * 3	X
 * 4	H
 *
 * Flag use:
 * 0	second derivative
 */
		LBL ENTRY_2DERIV			/* Entry: SECOND DERIVATIVE */
			XEQ entry
			LocR 04				/* Registers .00 to .04 */
			SPEC?
				JMP deriv_bad_input
			SF .00
			XEQ deriv_default_h
			1
			XEQ deriv_eval_func		/* f(x+h) + f(x-h)*/
				JMP deriv_bad_input
			1
			6
			[times]
			STO .01				/* order four estimate*/
			4
			2
			EEX
			3
			RCL[times] .00
			STO .02				/* order ten estimate*/
			0
			XEQ deriv_eval_func		/* f(x)*/
				JMP deriv_bad_input
			3
			0
			[times]
			STO- .01
			7
			3
			7
			6
			6
			RCL[times] .00
			STO- .02

			2
			XEQ deriv_eval_func		/* f(x+2h) + f(x-2h)*/
				JMP deriv_bad_input
			STO- .01
			6
			EEX
			3
			[times]
			STO- .02

			3
			XEQ deriv_eval_func		/* f(x+3h) + f(x-3h)*/
				JMP deriv2_4point
			EEX
			3
			[times]
			STO+ .02

			4
			XEQ deriv_eval_func		/* f(x+4h) + f(x-4h)*/
				JMP deriv2_4point
			1
			2
			5
			[times]
			STO- .02

			5
			XEQ deriv_eval_func		/* f(x+5h) + f(x-5h)*/
				JMP deriv2_4point
			8
			[times]
			RCL+ .02
			2
			5
			2
			SDL 02				/* * 100 = 25200*/
			RCL[times] .04
			RCL[times] .04
			/
			JMP deriv_return

deriv_bad_input::	Num NaN
			JMP deriv_return

deriv2_4point::		1
			2
			RCL[times] .04
			RCL[times] .04
			1/x
			STO[times] .01

deriv_6point::		RCL .01
			JMP deriv_return


		LBL ENTRY_DERIV				/* Entry: DERIVATIVE */
			XEQ entry
			LocR 04				/* Registers .00 to .04 */
			SPEC?
				JMP deriv_bad_input
			CF .00
			XEQ deriv_default_h
			1
			XEQ deriv_eval_func		/* f(x+h) - f(x-h)*/
				JMP deriv_bad_input
			STO .01

			2
			XEQ deriv_eval_func		/* f(x+2h) - f(x-2h)*/
				JMP deriv_bad_input
			STO .02

			/* At this point we can do a four point estimate if something goes awry */
			3
			XEQ deriv_eval_func		/* f(x+3h)-f(x-3h)*/
				JMP deriv_4point

			/* At this point we can do the six point estimate - calculate it now */
			4
			5
			RCL[times] .01
			9
			RCL[times] .02
			-
			+
			6
			0
			RCL[times] .04
			/
			x[<->] .01			/* Six point stimate in E2 & start ten point estimate*/
			2
			1
			SDL 02				/* * 100 = 2100*/
			[times]
			6
			SDL 02				/* * 100 = 600*/
			RCL[times] .02
			-
			1
			5
			0
			RCL[times] .00
			+				/* Ten point estimate to end up in E1*/

			STO .02
			4
			XEQ deriv_eval_func		/* f(x+4h) - f(x-4h)*/
				JMP deriv_6point
			2
			5
			[times]
			STO- .02

			5
			XEQ deriv_eval_func		/* f(x+5h) - f(x-5h)*/
				JMP deriv_6point
			RCL+ .00
			RCL+ .02
			2
			5
			2
			0
			RCL[times] .04
			/
			JMP deriv_return

			/* Eval f(X + k h) k on stack */
deriv_eval_func::	STO .00
			RCL[times] .04
			RCL+ .03
			FILL
			XEQUSR				/* f(x + k h)*/
			POPUSR
			SPEC?
				RTN
			x[<->] .00
			x=0?
				JMP deriv_skip_midpoint
			+/-
			RCL[times] .04
			RCL+ .03
			FILL
			XEQUSR				/* f(x - k h)*/
			POPUSR
			SPEC?
				RTN
			FS? .00
			+/-
			STO- .00

deriv_skip_midpoint::	RCL .00
			RTN+1

deriv_4point::		8
			RCL[times] .01
			RCL- .02
			1
			2
			RCL[times] .04
			/

deriv_return::		STO L
			iC 0
			FILL
			RCL .03
			x[<->] L
			RTN
/*
 *  This part contains double word instructions and must not be located between a
 *  JMP and its label because in XROM, BACK and SKIP are computed instead of 
 *  walking the PC. This would fail with a long instruction in between.
 */
deriv_default_h::	STO .03
			FILL
			LBL?'[delta]X'
				JMP deltaX
			iC 1
			SDR 01				/* default h = 0.1 */
			STO .04
			RTN

deltaX::		XEQ'[delta]X'
			STO .04
			RTN

/**************************************************************************/
/* A quadratic equation solver.
 * Based on code by Franz.
 *
 * Register use:
 * 0	c
 * 1	b^2 - 4ac
 * 2	2a
 * 3	t
 * 4	I
 */
		LBL ENTRY_QUAD				/* Entry: QUADRATIC SOLVER */
			XEQ entry
			XLOCAL				/* Registers .00 to .04 are used */
			STOS .00
			RCL I
			STO .04
			R[v]

			RCL+ X				/* 2c b a . */
			x[<->] Z				/* a b 2c . */
			x=0?
				ERR 18			/* Invalid arugment error */
			RCL+ X				/* 2a b 2c . */
			STO .02
			RCL Y				/* b 2a b 2c */
			[cmplx][times]			/* b^2-4ac 2b(a+c) b 2c */
			STO .01
			x<0?
				JMP quad_complex
			[sqrt]				/* sqrt 2b(a+c) b 2c */
			x[<->] Y				/* . sqrt b 2c */
			DROP				/* sqrt b 2c 2c */
			x[<->] Y				/* b sqrt 2c 2c */
			x[>=]0?
				[cmplx]CONJ
			-				/* -b-sqrt 2c 2c 2c */
                        x[!=]0?
			STO/ Y				/* -b-sqrt 2c/(-b-sqrt) 2c 2c */
			RCL/ .02			/* (b-sqrt)/2a 2c/(b-sqrt) 2c 2c */
			JMP quad_fix_stack

quad_complex::		ABS
			[sqrt]				/* sqrt ? b 2c */
			RCL/ .02			/* sqrt/2a ? b 2c */
			RCL Z				/* b sqrt/2a ? b */
			RCL/ .02			/* b/2a sqrt/2a ? b */
			+/-
			XEQ quad_fix_stack
			TOP?
				JMP quad_message
			RTN+1

quad_message::		CL[alpha]
			[alpha] C
			VW[alpha]+ X
			RTN

quad_fix_stack::	RCL .00
			STO L				/* Push c into Last X*/
			RCL .04
			STO I				/* Restore I*/
			[cmplx]x[<->] Z
			RCL .04				/* Restore T*/
			RCL .01				/* Preserve b^2 - 4ac*/
			[cmplx]x[<->] Z
			RTN

/**************************************************************************/

		LBL ENTRY_W1
			XEQ entry
			XLOCAL
			STOS .08
			SPEC?
				JMP LamW_NaN2
			x[>=]0?
				JMP LamW_inf
			STOS .08
			+/-
			1/x
			STO .00
			Num eE
			x>? Y
				JMP LamW_NaN
			RCL .00
LamW_loop::		STO .01
			LN
			RCL[times] .00
			RCL .01
			x[<->] Y
			-
			x=0?
				JMP LamW_exit
			RCL L
			JMP LamW_loop
LamW_exit::		RCL L
			RCL/ .00
			+/-
			JMP zeta_exit

LamW_inf::	x>0?
			JMP LamW_NaN2
		FC? D
			ERR 05
		Num -[infinity]
		JMP zeta_exit

LamW_NaN::	RCLS .08
LamW_NaN2::	FC? D
			ERR 01
		Num NaN
		JMP zeta_exit
		

/**************************************************************************/
		LBL ENTRY_Bn_star		/* Bernoulli number Bn* = +/- Bn(2 n) */
			XEQ entry
			FP?
				ERR 01
			x[<=]0?
				ERR 01
			XLOCAL
			STOS .08
			STO+ X
			XEQ bernoulli
			STO+ X
			ABS
			JMP zeta_exit

		LBL ENTRY_Bn			/* Bernoulli number Bn = -n zeta(1-n), n>=0 */
			XEQ entry
			FP?
				ERR 01
			x<0?
				ERR 01
			XLOCAL
			STOS .08
			x=0?
				JMP Bn_0
			x=1?
				JMP zeta_0
			ODD?
				JMP Bn_odd
			XEQ bernoulli
			JMP zeta_exit

bernoulli::		STO 12
			DEC X
			+/-
			XEQ zeta_int
			RCL[times] .08
			+/-
			RTN

Bn_odd::		iC 0
			JMP zeta_exit

Bn_0::			iC 1
			JMP zeta_exit

zeta_0::		.
			5
			+/-
			JMP zeta_exit

/**************************************************************************/
/* Zeta function implementation based on Jean-Marc Baillard's from:
 *	http://hp41programs.yolasite.com/zeta.php
 * This is the same algorithm as the C version uses, just with fewer terms and
 * with the constants computed on the fly.
 */
		LBL ENTRY_ZETA			/* Zeta function */
			XEQ entry
			XLOCAL
			STOS .08
			x=0?
				JMP zeta_0
			XEQ zeta_int

zeta_exit::		x[<->] .08
			STO L
			RCLS .08
			RTN
		
zeta_int::		STO .01
			STO .07
			.
			5
			x[<=]? Y
				JMP zeta_calc

zeta_neg::		SIGN
			x[<->] Y
			-
			STO .01
			XEQ zeta_calc
			iC 1
			ASIN
			RCL[times] .07
			SIN
			[times]
			[pi]		// Num [pi]
			STO/ Y
			STO+ X
			RCL .07
			y[^x]
			[times]
			x[<->] .01
			[GAMMA]
			RCL[times] .01
			RTN

zeta_calc::		2
			0
			STO .00
			STO .03
			SIGN
			STO .02
			STO .04
			STO .05
			+/-
			STO .06
			iC 0
zeta_loop::		RCL .05
			RCL .00
			RCL .01
			+/-
			y[^x]
			[times]
			RCL .06
			+/-
			STO .06
			[times]
			+
			RCL .00
			ENTER[^]
			STO+ Y
			STO[times] Y
			-
			RCL[times] .04
			RCL .03
			x[^2]
			RCL .00
			DEC X
			x[^2]
			-
			STO+ X
			/
			STO .04
			STO+ .05
			x[<->] Y
			DSE .00
				JMP zeta_loop

			RCL/ .05
			2
			LN
			iC 1
			RCL- .01
			[times]
			e[^x]-1
			/
			RTN

/**************************************************************************/

			/* We do not work in integer mode */
entry::			INTM?
				ERR 13			/* Error: bad mode error*/
			RTN

/**************************************************************************/
/* Very minimal routine to return the next prime in sequence
 */
		LBL ENTRY_NEXTPRIME
			FLOOR
			x[<=]1?
				JMP prime_2
			PRIME?
				INC X
			EVEN?
prime_loop::			INC X
			PRIME?
				RTN
			INC X
			JMP prime_loop

prime_2::		CLx
			2
			RTN
