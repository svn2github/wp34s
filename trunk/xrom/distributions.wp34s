/**************************************************************************/
/* Cauchy distribution
 * Two parameters:
 *	J = location (real)
 *	K = scale > 0
 * Formulas:
 *	pdf = (PI K (1 + ((x-J) / K)^2) )^-1
 *	cdf = arctan((x-J) / K) / PI + 1/2
 *	qf = J + K TAN(PI (p - 1/2))
 */
		XLBL"PDF_CAUCHY"
			xIN MONADIC
			GSB cauchy_xform
			SPEC?
				JMP ret_0	/* Can only be infinite which has zero probability */
			RCL[times] X
			INC X
			RCL[times] K
			[pi]
			[times]
			1/x
			xOUT xOUT_NORMAL

		XLBL"CDF_CAUCHY"
			xIN MONADIC
			GSB cauchy_xform
			SPEC?
				JMP cdf_infinite
			ATAN
			[pi]
			/
			.
			5
			+
			xOUT xOUT_NORMAL

cauchy_xform::		RCL- J
			GSB check_special
			RCL K
			GSB check_special_pos
			/
			RTN

		XLBL"QF_CAUCHY"
			xIN MONADIC
			GSB qf_check_probability
			.
			5
			-
			[pi]
			[times]
			TAN
			RCL K
			GSB check_special_pos
			[times]
			RCL+ J
			GSB check_special
			xOUT xOUT_NORMAL

/**************************************************************************/
/* Exponential distribution
 * One parameter:
 *	J = lambda (shape) > 0
 * Formulas:
 *	pdf = lambda exp(-lambda x)
 *	cdf = 1 - exp(-lambda x)
 *	qf = ln(1 - p) / -lambda
 */
		XLBL"PDF_EXPON"
			xIN MONADIC
			GSB expon_param
			SPEC?
				JMP ret_0	/* Can only be infinite which has zero probability */
			[times]
			x<0?
				JMP ret_0
			+/-
			e[^x]
			RCL[times] J
			xOUT xOUT_NORMAL

		XLBL"CDF_EXPON"
			xIN MONADIC
			GSB expon_param
			SPEC?
				JMP cdf_infinite
			[times]
			+/-
			e[^x]-1
			+/-
			xOUT xOUT_NORMAL

		XLBL"QF_EXPON"
			xIN MONADIC
			GSB qf_check_probability
			GSB log1m
			GSB expon_param
			/
			+/-
			xOUT xOUT_NORMAL

expon_param::		RCL J
			GSB check_special_pos
			RTN


/**************************************************************************/
/* Logistic distribution
 * Two parameters:
 *	J = mu (location)
 *	K = s (scale) > 0
 * Formulas:
 *	pdf = 1 / ( (cosh( (x-J) / 2K ) )^2 * 4 K)
 *	cdf = 1/2 + tanh( (x-J) / 2K ) / 2 = (1 + tanh( (x-J) / 2K)) / 2
 *	qf = arctanh( (p-1/2) * 2) * 2K + j = archtanh(2p - 1) * 2K + J
 */
		XLBL"PDF_LOGIT"
			xIN MONADIC
			GSB logistic_param
			SPEC?
				JMP ret_0
			COSH
			x[^2]
			RCL[times] K
			4
			[times]
			1/x
			xOUT xOUT_NORMAL

		XLBL"CDF_LOGIT"		/* (1 + tanh( (x-J) / 2K)) / 2 */
			xIN MONADIC
			GSB logistic_param
			SPEC?
				JMP cdf_infinite
			x[<=]0?
				JMP ret_0
			TANH
			INC X
			2
			/
			xOUT xOUT_NORMAL

/* Extra the logistic rescaled parameter (x-J) / 2K */
logistic_param::	RCL- J
			GSB check_special
			RCL K
			GSB check_special_pos
			RCL+ X
			/
			RTN
			
		XLBL"QF_LOGIT"		/* archtanh(2p - 1) * 2K + J */
			xIN MONADIC
			GSB qf_check_probability
			RCL+ X
			DEC X
			ATANH
			RCL+ X
			RCL K
			GSB check_special_pos
			[times]
			RCL J
			GSB check_special
			+
			xOUT xOUT_NORMAL


#ifdef NORMAL_DISTRIBUTION_AS_XROM
/**************************************************************************/
/* Log Normal distribution
 */
 		XLBL"PDF_LGNORM"
			xIN MONADIC
				LocR 00
				STO .00
				LN
				GSB pdf_normal
				RCL/ .00
			xOUT xOUT_NORMAL

		XLBL"CDF_LGNORM"
			xIN MONADIC
				SPEC?
					JMP cdf_infinite
				x[<=]0?
					JMP ret_0
				LN
				JMP cdf_normal

		XLBL"QF_LGNORM"
			xIN MONADIC
				GSB qf_normal
				e[^x]
			xOUT xOUT_NORMAL

/**************************************************************************/
/* Normal distribution
 */
 		XLBL"PDF_NORMAL"
			xIN MONADIC
				GSB pdf_normal
			xOUT xOUT_NORMAL

pdf_normal::		GSB normal_param
			GSB pdf_q
			RCL/ K
			RTN

		XLBL"CDF_NORMAL"
			xIN MONADIC
			SPEC?
				JMP cdf_infinite
cdf_normal::		GSB normal_param
			GSB cdf_q
			xOUT xOUT_NORMAL

normal_param::		RCL J
			GSB check_special
			-
			RCL K
			GSB check_special_pos
			/
			RTN

		XLBL"QF_NORMAL"
			xIN MONADIC
				GSB qf_normal
			xOUT xOUT_NORMAL

qf_normal::		GSB qf_q
			RCL K
			GSB check_special_pos
			[times]
			RCL J
			GSB check_special
			+
			RTN

/**************************************************************************/
/* Standard Normal distribution
 */
		XLBL"PDF_Q"
			xIN MONADIC
				GSB pdf_q
			xOUT xOUT_NORMAL

/* Standard entry point.  Uses one stack level and no last X */
pdf_q::			x[^2]
			2
			/
			+/-
			e[^x]
			GSB sqrt_2pi
			/
			RTN


		XLBL"CDF_Q"
			xIN MONADIC
				GSB cdf_q
			xOUT xOUT_NORMAL

/* Standard entry point.  Destroys the stack and uses local registers and
 * several stack level.  The alternate entry point is used, registers
 * .01 - .03 are destroyed, .00 holds the initial X and .04 holds the pdf(x).
 * Additionally, flag .00 is set if the X value is negative.
 */
cdf_q::			LocR 04
cdf_q_alt::		STO .00		// x in .00
			x<0?
				SF .00
			GSB pdf_q
			STO .04
			RCL .00
			ABS
			[pi]
			x[>=]? Y
				JMP cdf_q2

/* Code for |x| > 3.15 */
			DROP
			DEC X
			2
			5
			6
			x[<->] Y
			/
			4
			+
			CEIL
			STO .02		// n = (|x|-1)/256+4
			iC 0
cdf_q_lp1::		RCL .02		// n
			RCL .00		// x
			RCL+ Z		// x + term
			/		// n / (x + term)
			DSZ .02
				JMP cdf_q_lp1
			RCL+ .00
			RCL .04
			x[<->] Y
			/
			x<0?
				JMP cdf_q_skip1
			iC 1
			x[<->] Y
			-
cdf_q_skip1::		FS? .00
			+/-
			RTN

/* Alternate code for |x| < 3.15 */
cdf_q2::		3
			STO .03		// d = 3
			[cmplx]DROP
			STO .01
			STO[times] .01	// x2 = x^2
			STO .02		// a = |x|
cdf_q_lp2::		RCL[times] .01	// term * x^2
			RCL/ .03	// term * x^2 / d
			ENTER[^]
			x[<->] .02
			STO+ .02
			RCL .02
			CNVG? CVG_RELATIVE_DBL
				JMP cdf_q_skip2
			[cmplx]DROP
			INC .03
			INC .03
			JMP cdf_q_lp2
cdf_q_skip2::		RCL[times] .04
			.
			5
			x[<->] Y
			FS? .00
				-
			FC? .00
				+
			RTN


		XLBL"QF_Q"
			xIN MONADIC
				GSB qf_q
			xOUT xOUT_NORMAL

/* The internal Q qf entry point.  Sets flag .01 if x < 0.
 */
qf_q::			GSB qf_check_probability
			LocR 06
			STO .05		// save x
			.
			5
			x[<->] Y
			-
			STO .06		// b = 1/2 - x
			x=0?
				RTN
			/* Estimate an initial try */
			x[>=]0?
				JMP qf_q_inrange
			iC 1
			RCL- .05
			STO .05
			SF .01
qf_q_inrange::		RCL .05
			.
			2
			x<? Y
				JMP qf_q_skip2
			RCL .05
			LN
			RCL+ X
			+/-
			STO .06		// u = -2 LN(x)
			DEC X
			[sqrt]
			GSB sqrt_2pi
			[times]
			RCL[times] .05
			LN
			RCL+ X
			+/-
			[sqrt]
			x[<->] .06
			/
			RCL+ .06
				+/-
			JMP qf_q_est_done

qf_q_skip2::		GSB sqrt_2pi
			RCL[times] .06
			ENTER[^]
			CUBE
			6
			/
			+
			+/-

/* Now refine the estimate via Newton steps */
qf_q_est_done::		STO .06
qf_q_loop::		GSB cdf_q_alt		/* pdf in .04 */
			RCL- .05		/* cdf - x */
			RCL/ .04		/* (cdf - x) / pdf */
			ENTER[^]
			RCL[times] .06
			2
			/
			DEC X
			/
			x[<->] .06
			STO+ .06
			RCL .06
			CNVG? CVG_RELATIVE_DBL
				JMP qf_loop_end
			JMP qf_q_loop

qf_loop_end::		FS? .01
				+/-
			RTN

sqrt_2pi::		[pi]
			RCL+ X
			[sqrt]
			RTN

#endif


/**************************************************************************/
/* Weibull distribution
 * Two parameters:
 *	J = lambda (shape) > 0
 *	K = k (scale) > 0
 * Formulas:
 *	pdf = k/J (x/J)^(k-1) exp(-(x/J)^k)  x>=0, 0 otherwise
 *	cdf = 1 - exp( -(x/J)^k)
 *	qf = (-ln(1-p) ^ (1/k)) * J
 */
		XLBL"PDF_WEIB"
			xIN MONADIC
			GSB weibull_param
			RCL Y
			SPEC?
				JMP ret_0
			x[<=]0?
				JMP ret_0
			x[<->] Y
			y[^x]
			STO Z
			+/-
			e[^x]
			RCL[times] Z
			RCL/ Y
			RCL[times] K
			RCL/ J
			xOUT xOUT_NORMAL

		XLBL"CDF_WEIB"
			xIN MONADIC
			GSB weibull_param
			x[<->] Y
			x[<=]0?
				JMP ret_0
			SPEC?
				JMP ret_1	/* only +infinte left */
			x[<->] Y
			y[^x]
			+/-
			e[^x]-1
			+/-
			xOUT xOUT_NORMAL

weibull_param::		RCL J
			GSB check_special_pos
			/
			RCL K
			GSB check_special_pos
			RTN

		XLBL"QF_WEIB"			/* (-ln(1-p) ^ (1/k)) * J */
			xIN MONADIC
			GSB qf_check_probability
			GSB log1m
			+/-
			RCL K
			GSB check_special_pos
			1/x
			y[^x]
			RCL J
			GSB check_special_pos
			[times]
			xOUT xOUT_NORMAL

/**************************************************************************/
/* Utility conditional that checks if the argument is a valid probability or not */

cdf_infinite::		x<0?
				JMP ret_0
			JMP ret_1

check_probability::	NaN?
				JMP ret_NaN
qf_check_probability::	x<0?
				JMP ret_neginf
			x>1?
				JMP ret_posinf
			RTN
/* Error out if a number is zero, negative or special */
check_special_pos::	x[<=]0?
				ERR ERR_BAD_PARAM

/* Error out if a number is special */
check_special::		SPEC?
				ERR ERR_BAD_PARAM
			RTN

/**************************************************************************/
/* Some utility subroutines */

/* Log (1 - x) */
log1m::		+/-
		LN1+x
		RTN


