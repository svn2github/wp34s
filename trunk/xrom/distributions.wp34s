/* This file is part of 34S.
 * 
 * 34S is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * 34S is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with 34S.  If not, see <http://www.gnu.org/licenses/>.
 */

/* Define some identifying numbers for the distributions that require the Newton solver to
 * invert.
 */
#define DIST_T		(0)
#define DIST_CHI2	(1)
#define DIST_F		(2)
#define DIST_POISSON	(3)
#define DIST_BINOMIAL	(4)
#define DIST_GEOMETRIC	(5)


/**************************************************************************/
/* Binomial distribution
 * Two parameters:
 *	J = probabiliy
 *	K = n
 */
		XLBL"PDF_BINOMIAL"
			xIN MONADIC
			GSB binomial_param
			x<0?
				JMP ret_0
			x>? K
				JMP ret_0
			RCL J			// P	x
			GSB log1m		// LnP	x
			RCL K			// n LnP  x
			RCL- Z			// n-x LnP x
			[times]			// (n-x)LnP x
			e[^x]
			RCL K
			RCL Z
			COMB
			[times]
			RCL J
			RCL Z
			y[^x]
			[times]
			xOUT xOUT_NORMAL

#if 0
		XLBL"CDF_BINOMIAL"
			xIN MONADIC
			GSB binomial_param
			FLOOR
			GSB cdf_binomial
			xOUT xOUT_NORMAL

cdf_binomial::		x<0?
				JMP dist_ret_0
			x>? K
				JMP dist_ret_1
			RCL K
			RCL- Y			// n-x x+1 x
			_INT 1
			RCL+ Z			// x+1 x
			_INT 1
			RCL- J			// 1-p n-x x+1 x
			JMP betai

		XLBL"QF_BINOMIAL"
			RTN
#endif
binomial_param::	RCL J
			GSB check_probability
			RCL K
			SPEC?
				ERR ERR_BAD_PARAM
			FP?
				JMP ret_0
			x<0?
				JMP ret_0
			[cmplx]DROP
			RTN
#if 1
betai::			I[beta]
			RTN

gammap::		I[GAMMA]
			RTN

dist_ret_0::		_INT 0
			RTN

dist_ret_1::		_INT 1
			RTN
#endif
/**************************************************************************/
/* Cauchy distribution
 * Two parameters:
 *	J = location (real)
 *	K = scale > 0
 * Formulas:
 *	pdf = (PI K (1 + ((x-J) / K)^2) )^-1
 *	cdf = arctan((x-J) / K) / PI + 1/2
 *	qf = J + K TAN(PI (p - 1/2))
 */
		XLBL"PDF_CAUCHY"
			xIN MONADIC
			GSB cauchy_xform
			SPEC?
				JMP ret_0	/* Can only be infinite which has zero probability */
			RCL[times] X
			INC X
			RCL[times] K
			Num [pi]
			[times]
			1/x
			xOUT xOUT_NORMAL

		XLBL"CDF_CAUCHY"
			xIN MONADIC
			GSB cauchy_xform
			SPEC?
				JMP cdf_infinite
			ATAN
			Num [pi]
			/
			.
			5
			+
			xOUT xOUT_NORMAL

cauchy_xform::		RCL- J
			GSB check_special
			RCL K
			GSB check_special_pos
			/
			RTN

		XLBL"QF_CAUCHY"
			xIN MONADIC
			GSB qf_check_probability
			.
			5
			-
			Num [pi]
			[times]
			TAN
			RCL K
			GSB check_special_pos
			[times]
			RCL+ J
			GSB check_special
			xOUT xOUT_NORMAL

/**************************************************************************/
/* Chi-squared distribution
 * One parameters:
 *	n positive integer
 */
#if 0
		XLBL"PDF_CHI2"
			xIN MONADIC
			GSB chi2_param
			GSB pdf_chi2
			xOUT xOUT_NORMAL

pdf_chi2::		x[<=]? 0
				JMP dist_ret_0
			RCL J
			_INT 2
			/		// k/2 x ? ?
			[<->] YXXX	// x k/2 k/2 k/2
			LN		// LNx k/2 k/2 k/2
			RCL L		// x LNx k/2 k/2
			_INT 2
			/		// x/2 LNx k/2 ?
			+/-		// -x/2 LNx k/2 ?
			[<->] ZYXZ	// k/2 LNx -x/2 k/2
			DEC X
			[times]		// (k/2-1)LNx -x/2 k/2 ?
			+		// sum k/2 ? ?
			[<->] YXYY	// k/2 sum k/2 k/2
			LN[GAMMA]
			-		// sum k/2 k/2 ?
			Num LN2
			RCL[times] Z
			-
			e[^x]
			RTN

		XLBL"CDF_CHI2"
			xIN MONADIC
			GSB chi2_param
			GSB cdf_chi2
			xOUT xOUT_NORMAL

cdf_chi2::		x[<=]? 0
				JMP dist_ret_0
			[infinity]?
				JMP dist_ret_1
			_INT 2
			/
			RCL J
			_INT 2
			/
			SWAP
			JMP gammap

chi2_param::		RCL J
			GSB check_special_notneg
			FP?
				ERR ERR_BAD_PARAM
			DROP
			RTN
				
		XLBL"QF_CHI2"
			xIN MONADIC
			GSB chi2_param
			NOP
			xOUT xOUT_NORMAL
#endif

/**************************************************************************/
/* Exponential distribution
 * One parameter:
 *	J = lambda (shape) > 0
 * Formulas:
 *	pdf = lambda exp(-lambda x)
 *	cdf = 1 - exp(-lambda x)
 *	qf = ln(1 - p) / -lambda
 */
		XLBL"PDF_EXPON"
			xIN MONADIC
			GSB expon_param
			SPEC?
				JMP ret_0	/* Can only be infinite which has zero probability */
			[times]
			x<0?
				JMP ret_0
			+/-
			e[^x]
			RCL[times] J
			xOUT xOUT_NORMAL

		XLBL"CDF_EXPON"
			xIN MONADIC
			GSB expon_param
			SPEC?
				JMP cdf_infinite
			[times]
			+/-
			e[^x]-1
			+/-
			xOUT xOUT_NORMAL

		XLBL"QF_EXPON"
			xIN MONADIC
			GSB qf_check_probability
			GSB log1m
			GSB expon_param
			/
			+/-
			xOUT xOUT_NORMAL

expon_param::		RCL J
			GSB check_special_pos
			RTN


/**************************************************************************/
/* F distribution
 * Two parameteres:
 *	J = df1 (real > 0)
 *	K = df2 (real > 0)
 */
#if 0
		XLBL"PDF_F"
			xIN MONADIC
			GSB f_param
			GSB pdf_f
			xOUT xOUT_NORMAL

pdf_f::			FILL
			RCL K
			LN		// Lnd2 x x
			RCL[times] K	// d2Lnd2 x x
			RCL J		// d1 d2Lnd2 x x
			RCL[times] Z	// xd1 d2Lnd2 x x
			STO Z
			LN		// LNxd1 d2Lnd2 xd1 x
			RCL[times] J	// d1Lnxd1 d2Lnd2 xd1 x
			+		// sum xd1 x
			SWAP		// xd1 sum x
			RCL+ K		// xd1+d2 sum x
			LN		// Lnxd1+d2 sum x
			RCL J		// d1 Lnxd1+d2 sum x
			RCL+ K		// d1+d2 Lnxd1+d2 sum x
			[times]		//(d1+d2)Lnxd1+d2 sum x
			-		// sum x ? ?
			_INT 2
			/		// Sum/2 x ? ?
			RCL J
			_INT 2		// 2 d1 Sum/2 x
			/		// d1/2 Sum/2 x
			RCL K		// d2 d1/2 Sum/2 x
			RCL/ L		// d2/2 d1/2 Sum/2 x
			LN[beta]	// Lnbeta Sum/2 x
			-
			e[^x]
			SWAP
			/
			RTN



		XLBL"CDF_F"
			xIN MONADIC
			GSB f_param
			GSB cdf_f
			xOUT xOUT_NORMAL

cdf_f::			x[<=]0?
				JMP dist_ret_0
			[infinity]?
				JMP dist_ret_1
			RCL[times] J
			ENTER[^]
			RCL+ K		// x*v1+v2  x*v1  ?  ?
			/
			RCL K		// v2  x*v1 / (x*v1+v2)
			_INT 2
			/
			RCL J
			_INT 2
			/
			[<->] ZYXT
			JMP betai

		XLBL"QF_F"
			xIN MONADIC
			GSB f_param
			xOUT xOUT_NORMAL

f_param::		RCL J
			GSB check_special_pos
//			FP?
//				ERR ERR_BAD_PARAM
			RCL K
			GSB check_special_pos
//			FP?
//				ERR ERR_BAD_PARAM
			[cmplx]DROP
			RTN
#endif
/**************************************************************************/
/* Geometric distribution
 * One parameter:
 *	J = probability
 */
		XLBL"PDF_GEOM"
			xIN MONADIC
			GSB geom_param
			x<0?
				JMP ret_0
			FP?
				JMP ret_0
			RCL J
			GSB log1m
			[times]
			e[^x]
			RCL[times] J
			xOUT xOUT_NORMAL

		XLBL"CDF_GEOM"
			xIN MONADIC
			GSB geom_param
			GSB cdf_geom
			xOUT xOUT_NORMAL

cdf_geom::		x<0?
				JMP dist_ret_0
			[infinity]?
				JMP dist_ret_1
			FLOOR
			INC X
			RCL J
			GSB log1m
			[times]
			e[^x]-1
			+/-
			RTN

		XLBL"QF_GEOM"
			xIN MONADIC
			GSB geom_param
			x<0?
				JMP ret_0
			GSB qf_check_probability
			ENTER[^]
			GSB log1m
			RCL J
			GSB log1m
			/
			DEC X
			FLOOR
			_INT (DIST_GEOMETRIC - DIST_POISSON)

#define R_DIST	.00
#define R_R	.01
#define R_P	.02
qf_discrete_final::	LocR 3
			[cmplx]STO R_DIST
			z[<->] R_P
			DROP
			GSB qf_discrete_cdf
			x>? R_P
				JMP qf_discrete_1high
			RCL R_R
			INC X
			GSB qf_discrete_cdf
			x[<=]? R_P
				INC R_R
qf_discrere_out::	RCL R_R
			xOUT xOUT_NORMAL
qf_discrete_1high::	DEC R_R
			JMP qf_discrere_out


qf_discrete_cdf::	iSKIP[->]R_DIST
			JMP cdf_poisson
			JMP cdf_binomial
			JMP cdf_geom	
#undef R_R
#undef R_P
#undef R_DIST

#if 1
cdf_poisson::		Pois[lambda]
			RTN
cdf_binomial::		Binom
			RTN
#endif

geom_param::		RCL J
			GSB check_probability
			DROP
			RTN

/**************************************************************************/
/* Logistic distribution
 * Two parameters:
 *	J = mu (location)
 *	K = s (scale) > 0
 * Formulas:
 *	pdf = 1 / ( (cosh( (x-J) / 2K ) )^2 * 4 K)
 *	cdf = 1/2 + tanh( (x-J) / 2K ) / 2 = (1 + tanh( (x-J) / 2K)) / 2
 *	qf = arctanh( (p-1/2) * 2) * 2K + j = archtanh(2p - 1) * 2K + J
 */
		XLBL"PDF_LOGIT"
			xIN MONADIC
			GSB logistic_param
			SPEC?
				JMP ret_0
			COSH
			x[^2]
			RCL[times] K
			_INT 4
			[times]
			1/x
			xOUT xOUT_NORMAL

		XLBL"CDF_LOGIT"		/* (1 + tanh( (x-J) / 2K)) / 2 */
			xIN MONADIC
			GSB logistic_param
			SPEC?
				JMP cdf_infinite
			x[<=]0?
				JMP ret_0
			TANH
			INC X
			_INT 2
			/
			xOUT xOUT_NORMAL

/* Extra the logistic rescaled parameter (x-J) / 2K */
logistic_param::	RCL- J
			GSB check_special
			RCL K
			GSB check_special_pos
			RCL+ X
			/
			RTN
			
		XLBL"QF_LOGIT"		/* archtanh(2p - 1) * 2K + J */
			xIN MONADIC
			GSB qf_check_probability
			RCL+ X
			DEC X
			ATANH
			RCL+ X
			RCL K
			GSB check_special_pos
			[times]
			RCL J
			GSB check_special
			+
			xOUT xOUT_NORMAL


/**************************************************************************/
/* Log Normal distribution
 */
 		XLBL"PDF_LOGNORMAL"
			xIN MONADIC
				LocR 01
				STO .00
				LN
				GSB pdf_normal
				RCL/ .00
			xOUT xOUT_NORMAL

		XLBL"CDF_LOGNORMAL"
			xIN MONADIC
				SPEC?
					JMP cdf_infinite
				x[<=]0?
					JMP ret_0
				LN
				JMP cdf_normal

		XLBL"QF_LOGNORMAL"
			xIN MONADIC
				GSB qf_normal
				e[^x]
			xOUT xOUT_NORMAL

/**************************************************************************/
/* Normal distribution
 */
#ifdef NORMAL_DISTRIBUTION_AS_XROM
#define X(a, b)		a
#else
#define X(a, b)		b
#endif
 		XLBL"PDF_NORMAL"
			xIN MONADIC
				GSB pdf_normal
			xOUT xOUT_NORMAL

pdf_normal::		GSB normal_param
			X(GSB pdf_q, [phi](x))
			RCL/ K
			RTN

		XLBL"CDF_NORMAL"
			xIN MONADIC
			SPEC?
				JMP cdf_infinite
cdf_normal::		GSB normal_param
			X(GSB cdf_q, [PHI](x))
			xOUT xOUT_NORMAL

normal_param::		RCL J
			GSB check_special
			-
			RCL K
			GSB check_special_pos
			/
			RTN

		XLBL"QF_NORMAL"
			xIN MONADIC
				GSB qf_normal
			xOUT xOUT_NORMAL

qf_normal::		X(GSB qf_q, [PHI][^-1](p))
			RCL K
			GSB check_special_pos
			[times]
			RCL J
			GSB check_special
			+
			RTN
#undef X

#ifdef NORMAL_DISTRIBUTION_AS_XROM
/**************************************************************************/
/* Standard Normal distribution
 */
		XLBL"PDF_Q"
			xIN MONADIC
pdf_q_xout::		GSB pdf_q
			xOUT xOUT_NORMAL

/* Standard entry point.  Uses one stack level and no last X */
pdf_q::			x[^2]
			_INT 2
			/
			+/-
			e[^x]
			Num [sqrt]2[pi]
			/
			RTN


		XLBL"CDF_Q"
			xIN MONADIC
cdf_q_xout::		GSB cdf_q
			xOUT xOUT_NORMAL

/* Standard entry point.  Destroys the stack.
 * Returns the CDF in X and the PDF in Y.
 */
cdf_q::			LocR 05
			STO .00		// x in .00
			x<0?
				SF .00
			GSB pdf_q
			STO .04
			RCL .00
			ABS
			Num [pi]
			x[>=]? Y
				JMP cdf_q2

/* Code for |x| > 3.15 */
			DROP
			DEC X
			_INT 128	// 256 the hard way
			RCL+ X
			SWAP
			/
			_INT 4
			+
			CEIL
			STO .02		// n = (|x|-1)/256+4
			Num 0
cdf_q_lp1::		RCL .02		// n
			RCL .00		// x
			RCL+ Z		// x + term
			/		// n / (x + term)
			DSZ .02
				JMP cdf_q_lp1
			RCL+ .00
			RCL .04
			SWAP
			/
			x<0?
				JMP cdf_q_skip1
			Num 1
			SWAP
			-
cdf_q_skip1::		FS? .00
				+/-
cdf_q_exit::		RCL .04
			SWAP
			RTN

/* Alternate code for |x| < 3.15 */
cdf_q2::		_INT 3
			STO .03		// d = 3
			[cmplx]DROP
			STO .01
			STO[times] .01	// x2 = x^2
			STO .02		// a = |x|
cdf_q_lp2::		RCL[times] .01	// term * x^2
			RCL/ .03	// term * x^2 / d
			ENTER[^]
			x[<->] .02
			STO+ .02
			RCL .02
			CNVG? CVG_RELATIVE_DBL
				JMP cdf_q_skip2
			[cmplx]DROP
			INC .03
			INC .03
			JMP cdf_q_lp2
cdf_q_skip2::		RCL[times] .04
			.
			5
			SWAP
			FS? .00
				-
			FC? .00
				+
			JMP cdf_q_exit


		XLBL"QF_Q"
			xIN MONADIC
qf_q_xout::		GSB qf_q
			xOUT xOUT_NORMAL
qf_q::			GSB qf_check_probability
			LocR 002
			STO .00
			x<0?
				SF .01
			GSB qf_q_est
			STO .01

/* Now refine the estimate via Newton steps */
qf_q_loop::		GSB cdf_q		/* pdf in Y */
			RCL- .00		/* cdf - x */
			RCL/ Y			/* (cdf - x) / pdf */
			ENTER[^]
			RCL[times] .01
			_INT 2
			/
			DEC X
			/
			x[<->] .01
			STO+ .01
			RCL .01
			CNVG? CVG_RELATIVE_DBL
				JMP qf_loop_end
			JMP qf_q_loop

qf_loop_end::		FS? .01
				+/-
			RTN

/* The internal Q qf entry point.
 */
qf_q_est::		LocR 02
			STO .00		// save x
			.
			5
			SWAP
			-
			STO .01		// b = 1/2 - x
			x=0?
				RTN
			/* Estimate an initial try */
			x[>=]0?
				JMP qf_q_inrange
			Num 1
			RCL- .00
			STO .00
			SF .00
qf_q_inrange::		RCL .00
			.
			2
			x<? Y
				JMP qf_q_skip2
			RCL .00
			LN
			RCL+ X
			+/-
			STO .01		// u = -2 LN(x)
			DEC X
			[sqrt]
			Num [sqrt]2[pi]
			[times]
			RCL[times] .00
			LN
			RCL+ X
			+/-
			[sqrt]
			x[<->] .01
			/
			RCL+ .01
			FC? .00
qf_q_neg_fin::			+/-
			RTN

qf_q_skip2::		Num [sqrt]2[pi]
			RCL[times] .01
			ENTER[^]
			x[^3]
			_INT 6
			/
			+
			JMP qf_q_neg_fin

#endif


/**************************************************************************/
/* One parameter Poission distribution
 * Real parameter lambda in J.
 */
		XLBL"PDF_POISSON"
			xIN MONADIC
			GSB poission1_param
pdf_poisson::		FP?
				JMP ret_0
			RCL J
			SWAP
			y[^x]
			RCL L
			x!
			/
			RCL J
			e[^x]
			/
			xOUT xOUT_NORMAL

#if 0
		XLBL"CDF_POISSON"
			xIN MONADIC
			GSB poission1_param
			FLOOR
			GSB cdf_poisson
			xOUT xOUT_NORMAL

cdf_poisson::		x<0?
				JMP dist_ret_0
			[infinity]?
				JMP dist_ret_1
			INC X
			RCL J
			GSB gammap
			_INT 1
			SWAP
			-
			RTN

		XLBL"QF_POISSON"
			RTN
#endif

poission1_param::	x[<->] J
			NaN?
				JMP ret_NaN
			SPEC?
				ERR ERR_BAD_PARAM
			x<0?
				JMP ret_0
			x[<->] J
			RTN

/**************************************************************************/
/* Two parameter Poission distribution
 * Porbability in J
 * n in K
 */
		XLBL"PDF_POIS2"
			xIN MONADIC
			GSB poisson2_param
			JMP pdf_poisson

		XLBL"CDF_POIS2"
			xIN MONADIC
			GSB poisson2_param
#if 0
			GSB cdf_poisson
#else
			Pois[lambda]
#endif
			xOUT xOUT_NORMAL

		XLBL"QF_POIS2"
			xIN MONADIC
			GSB poisson2_param
			Pois[lambda][^-1]
			xOUT xOUT_NORMAL

poisson2_param::	x[<->] J
			GSB check_probability
			RCL[times] K
			x<0?
				JMP ret_0
			x[<->] J
			RTN

/**************************************************************************/
/* Student's T distribution
 * One parameter:
 *	J = degrees of freedom (real > 0)
 */
#if 0
		XLBL"PDF_T"
			xIN MONADIC
			GSB t_param
#ifdef NORMAL_DISTRIBUTION_AS_XROM
			FS?C .00
				JMP pdf_q_xout
#endif
			GSB pdf_t
			xOUT xOUT_NORMAL

pdf_t::			RCL[times] X	// x^2 ? ? ?
			RCL J
			_INT 2
			/		// v/2 x^2 ? ?
			LN[GAMMA]	// LnG x^2 ? ?
			RCL L		// v/2 LnG x^2 ?
			.
			5
			+		// (v+1)/2 LnG x^2 ?
			STO T		// (v+1)/2 LnG x^2 (v+1)/2
			LN[GAMMA]	// LnG2 LnG x^2 (v+1)/2
			SWAP
			-		// LnG-LnG2 x^2 (v+1)/2 ?
			[<->] YZXT	// x^2 (v+1)/2 LnG-LnG2 ?
			RCL/ J		// x^2/v (v+1)/2 LnG-LnG2 ?
			LN1+x
			[times]		// LN1+* LnG-LnG2 ?
			-
			e[^x]
			Num [pi]
			RCL[times] J
			[sqrt]
			/
			RTN

		XLBL"CDF_T"
			xIN MONADIC
			GSB t_param
#ifdef NORMAL_DISTRIBUTION_AS_XROM
			FS?C .00
				JMP cdf_q_xout
#endif
			GSB cdf_t
			xOUT xOUT_NORMAL

cdf_t::			[infinity]?
				JMP cdf_t_infinite
			x=0?
				JMP dist_ret_half
			x>0?
				JMP cdf_t_invert
cdf_t_return::		RCL J		// v x ? ?
			SWAP		// x v ? ?
			x[^2]		// x^2 v ? ?
			RCL+ J		// v+x^2 v ? ?
			/		// v/(v+x^2) ? ? ?
			.
			5
			RCL J
			_INT 2
			/		// v/2 .5 v/(v+x^2) ?
			[<->] ZYXT
			GSB betai
			_INT 2
			/
			RTN

cdf_t_invert::		GSB cdf_t_return
			_INT 1
			SWAP
			-
			RTN

cdf_t_infinite::	x<0?
				JMP dist_ret_0
			JMP dist_ret_1

dist_ret_half::		.
			5
			RTN


		XLBL"QF_T"
			xIN MONADIC
			GSB t_param
			GSB qf_check_probability
#ifdef NORMAL_DISTRIBUTION_AS_XROM
			FS?C .00
				JMP qf_q_xout
#endif
			xOUT xOUT_NORMAL

t_param::		RCL J
			[infinity]?
				JMP t_param_inf
			GSB check_special_pos
t_drop_rtn::		DROP
			RTN

t_param_inf::		x<0?
				ERR ERR_BAD_PARAM
			SF .00
			JMP t_drop_rtn
#endif

/**************************************************************************/
/* Weibull distribution
 * Two parameters:
 *	J = lambda (shape) > 0
 *	K = k (scale) > 0
 * Formulas:
 *	pdf = k/J (x/J)^(k-1) exp(-(x/J)^k)  x>=0, 0 otherwise
 *	cdf = 1 - exp( -(x/J)^k)
 *	qf = (-ln(1-p) ^ (1/k)) * J
 */
		XLBL"PDF_WEIB"
			xIN MONADIC
			GSB weibull_param
			RCL Y
			SPEC?
				JMP ret_0
			x[<=]0?
				JMP ret_0
			SWAP
			y[^x]
			STO Z
			+/-
			e[^x]
			RCL[times] Z
			RCL/ Y
			RCL[times] K
			RCL/ J
			xOUT xOUT_NORMAL

		XLBL"CDF_WEIB"
			xIN MONADIC
			GSB weibull_param
			SWAP
			x[<=]0?
				JMP ret_0
			SPEC?
				JMP ret_1	/* only +infinte left */
			SWAP
			y[^x]
			+/-
			e[^x]-1
			+/-
			xOUT xOUT_NORMAL

weibull_param::		RCL J
			GSB check_special_pos
			/
			RCL K
			GSB check_special_pos
			RTN

		XLBL"QF_WEIB"			/* (-ln(1-p) ^ (1/k)) * J */
			xIN MONADIC
			GSB qf_check_probability
			GSB log1m
			+/-
			RCL K
			GSB check_special_pos
			1/x
			y[^x]
			RCL J
			GSB check_special_pos
			[times]
			xOUT xOUT_NORMAL

/**************************************************************************/
/* Utility conditional that checks if the argument is a valid probability or not */

cdf_infinite::		x<0?
				JMP ret_0
			JMP ret_1

check_probability::	NaN?
				JMP ret_NaN
			x<0?
				ERR ERR_BAD_PARAM
			x>1?
				ERR ERR_BAD_PARAM
			RTN

qf_check_probability::	NaN?
				JMP ret_NaN
			x<0?
				JMP ret_NaN
			x>1?
				JMP ret_NaN
			RTN

/* Error out if a number is negative, zero or special */
check_special_pos::	x=0?
				ERR ERR_BAD_PARAM

/* Error out if a number is negative or special */
check_special_notneg::	x<0?
				ERR ERR_BAD_PARAM

/* Error out if a number is special */
check_special::		SPEC?
				ERR ERR_BAD_PARAM
			RTN

/**************************************************************************/
/* Some utility subroutines */

/* Log (1 - x) */
log1m::		+/-
		LN1+x
		RTN

#if 0
/**************************************************************************/
/* The Newton step solver.
 * Target value in Y, function identifier in X.
 */
/* Register use:
 */
#define R_DIST		.00
#define R_P		.01
#define R_ITERATIONS	.02
#define R_LOW		.03
#define R_HIGH		.04
#define R_MAXSTEP	.05
#define R_R		.06
#define R_Z		.07
#define R_W		.08

/* Flag use:
 */
#define F_DISCRETE	.00
#define F_NONNEGATIVE	.01
#define F_NOBISECT	.02

qf_newton::		LocR 009
			[cmplx]STO .00
			z[<->] R_R

			/* Set flags based on distribution */
			x=0?
				JMP qf_newton_flag_done	/* Student's T sets no flags */
			SF F_NONNEGATIVE		/* All the rest are non-negative */
			DEC X
			x>1?
				SF F_DISCRETE		/* Binomial is discrete and non-negative */

qf_newton_flag_done::	_INT 100
			STO R_ITERATIONS
			_Num infinity
			STO R_HIGH
			STO R_MAXSTEP
			+/-
			FS? F_NONNEGATIVE
				_INT 0
			STO R_LOW


qf_newton_search::	RCL R_R
			x[>=]? R_HIGH
				JMP qf_newton_try_bisect
			x[<=]? R_LOW
				JMP qf_newton_try_bisect
qf_newton_no_bisect::	RCL R_R
			GSB qf_newton_cdf
			STO R_W
			RCL- R_P
			STO R_Z
			x>0?
				JMP qf_newton_fix_high
			FS? F_NOBISECT
				JMP qf_newton_fix_low2
			RCL R_R
			x>? R_LOW
				JMP qf_newton_fix_low3
			RCL R_HIGH
			[infinity]?
				JMP qf_newton_fix_low2
			JMP qf_newton_do_bisect
qf_newton_fix_low2::	RCL R_R
qf_newton_fix_low3::	STO[^] R_LOW
			JMP qf_newton_fixed
qf_newton_fix_high::	FS? F_NOBISECT
				JMP qf_newton_fix_high2
			RCL R_R
			x<? R_HIGH
				JMP qf_newton_fix_high3
			RCL R_LOW
			[infinity]?
				JMP qf_newton_fix_high2
			JMP qf_newton_do_bisect
qf_newton_fix_high2::	RCL R_R
qf_newton_fix_high3::	STO[v] R_HIGH

/* Evaluated the CDF and it is within the bounds */
qf_newton_fixed::	CF F_NOBISECT
			GSB qf_newton_pdf
			x=0?
				JMP qf_newton_flat
			RCL R_Z
			SWAP
			/
			NOP	// limit max step
			RTN

/* The estimate is out of the ( low, high ) bounds.  Check to see if we can bisect instead */
qf_newton_try_bisect::	RCL R_HIGH
			[infinite]?
				JMP qf_newton_overlow
			RCL R_LOW
			[infinite]?
				JMP qf_newton_underhigh	
qf_newton_do_bisect::	RCL R_LOW
			RCL+ R_HIGH
			_INT 2
			/
			SF F_NOBISECT
qf_newton_bisect_out::	STO R_R
			JMP qf_newton_no_bisect
qf_newton_overlow::	RCL R_LOW
			RCL+ X
			JMP qf_newton_bisect_out
qf_newton_underhigh::	RCL R_HIGH
			_INT 2
			/
			JMP qf_newton_bisect_out


/* Discrete distribtions require an extra check to push the final answer
 * up or down one to account for any possible rounding issues.
 */
qf_discrete_exit::	RCL R_DIST
			_INT DIST_POISSON
			-
			z[<->] R_P
			JMP qf_discrete_final

/* Dispatchers to the PDF and CDF of the distribution being searched */
qf_newton_pdf::		iSKIP[->]R_DIST
			JMP pdf_t
			JMP pdf_chi2
			JMP pdf_F
			JMP pdf_discrete		// Poisson
			//JMP pdf_discrete		// Binomial

/* Using the pdf for the slope isn't great for the discrete distributions
 * So we do something more akin to a secant approach
 */
pdf_discrete::		_INT 1
			SDR 03
			RCL+ R_R
			GSB qf_newton_cdf
			RCL- R_W
			_INT 1
			SDL 3
			[times]
			RTN

qf_newton_cdf::		iSKIP[->]R_DIST
			JMP cdf_t
			JMP cdf_chi2
			JMP cdf_F
			JMP cdf_poisson
			JMP cdf_binomial
#undef F_DISCRETE
#undef F_NONNEGATIVE
#undef F_ALLOWBISECT

#undef R_P
#undef R_DIST
#undef R_ITERATIONS
#undef R_LOW
#undef R_HIGH
#undef R_MAXSTEP
#undef R_R
#undef R_Z
#undef R_W

#endif

#undef DIST_T
#undef DIST_CHI2
#undef DIST_F
#undef DIST_POISSON
#undef DIST_BINOMIAL
#undef DIST_GEOMETRIC

