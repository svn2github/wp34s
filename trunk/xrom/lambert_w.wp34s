/* This file is part of 34S.
 * 
 * 34S is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * 34S is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with 34S.  If not, see <http://www.gnu.org/licenses/>.
 */

/**************************************************************************/
/* The positive branch of the real W function.
 * A rough guess is made and then Newton's method is used to attain
 * convergence.  The C version (in ../trunk/unused/lambertW.c) works
 * similarily but uses Halley's method which converges a cubically
 * instead of quadratically.
 *
 * This code is based on a discussion on the MoHPC.  Search the archives
 * for "Lambert W (HP-41)" starting on the 2 Sept 2012.  The actual code
 * is Dieter's from a message posted on the 16th of Sept 2012.
 */

			XLBL"W0"
			xIN MONADIC
			SPEC?
				JMP ret_NaN
			x=0?
				xOUT xOUT_NORMAL
			JMP LamW0_common

/**************************************************************************/
/* The negative branch of the real W function.
 */

			XLBL"W1"
			xIN MONADIC
			SPEC?
				JMP ret_NaN
			x>0?
				JMP ret_NaN
			x=0?
				JMP ret_neginf
			SF .00

LamW0_common::		LocR 002
			STO .00
			+/-
			1/x
			Num eE
			x>? Y
				JMP ret_NaN

			_INT 007		// max. number of iterations
			STO .01
#if 0
			_INT 028
			SDR 002
#else
			1/x
			FC? .00
			STO+ X
#endif
			+/-			// threshold = -0.28
			RCL .00			// is used to determine
			x>? Y			// whether x is close to -1/e or not
				JMP LamW0_high_guess
			Num eE			// rounds to ...609 (DP) resp. ...424 (SP)
			1/x
			RCL+ .00
			Num eE
			[times]
			STO+ X
			[sqrt]
			FS?C .00		// use positive or negative sqrt for W_p resp. W_m
				+/-
			DEC X
				JMP LamW0_iterate	// start iteration

			// initial guess for x not close to -1/e
LamW0_high_guess::	FS?C .00		// Flag 0 set => jump to W_m guess
				JMP LamW0_Wm_guess
			LN1+x			// else calculate a guess for W_p
			ENTER[^]
			x>0?
				LN
			x<0?
				CLx
			-			// initial guess for W_p and x not close to -1/e
			JMP LamW0_iterate	// start iteration with this guess

LamW0_Wm_guess::	+/-
			LN
			ENTER[^]
			+/-
			LN
			-			// initial guess for W_m and x not close to -1/e
LamW0_iterate::		FILL			// iteration starts here
			RCL .00
			x[<->] Y
			e[^x]
			/
			-
			x[<->] Y
			INC X
			/
			RCL L
			1/x
			INC X
			RCL[times] Y
			Num 1/2
			[times]
			+/-
			INC X
			/
			-
			FS?C .01     		// "last iteration" flag set?
				JMP LamW0_finish	// then exit
			CNVG? 01		// relative error < 1E-24?  Halley's method will give us as close to full accuracy next iteration anyway
				SF .01		// then do one final iteration
			DSE .01			// but not more than 7
				JMP LamW0_iterate

#if 0
			ENTER[^]		// estimate potential error
			e[^x]
			RCL+ .00
			Num 1/2
			x[<->] Y
			/
			INC X
			ROUNDI			// estimated uncertainty in ULPs
			x[<->] Y		// is returned in Y
#endif
LamW0_finish::		xOUT xOUT_NORMAL
			
/**************************************************************************/
/* The positive branch of the complex W function.
 *
 * This code is based on Jean-Marc Baillard's HP-41 version from:
 *	http://hp41programs.yolasite.com/lambertw.php
 *
 * Register use:
 *	.00/.01	z
 *	.02/.03	w
 *	.04/.05	temporary
 */
			XLBL"CPX_W0"
			xIN MONADIC_COMPLEX
			LocR 06
			[cmplx]STO .00
			Num 1
			STO .02
			STO .03
			+
			[cmplx]x=0?
				JMP LamW_cloop
			[cmplx]LN
			[cmplx]STO .02
LamW_cloop::		[cmplx]ENTER
			[cmplx]e[^x]
			[cmplx]STO .04
			[cmplx]RCL[times] .02
			[cmplx]STO+ .04
			[cmplx]RCL- .00
			[cmplx]RCL/ .04
			[cmplx]STO- .02
			[cmplx]DROP
			[cmplx]RCL .02
			CNVG? CVG_COMPLEX
				xOUT xOUT_NORMAL
			JMP LamW_cloop

/**************************************************************************/
/* The inverse W function in both real and complex domains.
 */

			XLBL"W_INVERSE"
			xIN MONADIC
				e[^x]
				RCL[times] L
			xOUT xOUT_NORMAL

			XLBL"CPX_W_INVERSE"
			xIN MONADIC_COMPLEX
				[cmplx]e[^x]
				[cmplx]RCL[times] L
			xOUT xOUT_NORMAL
