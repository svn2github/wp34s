
/**************************************************************************/
/* The positive branch of the real W function.
 * A rough guess is made and then Newton's method is used to attain
 * convergence.  The C version works similarily but uses Halley's
 * method which converges a cubically instead of quadratically.
 *
 * MORE - needs conversion to double precision.
 *
 * This code is based on Jean-Marc Baillard's HP-41 version from:
 *	http://hp41programs.yolasite.com/lambertw.php
 */

		XLBL"W0"
			INTM?
				ERR ERR_BAD_MODE
			XLOCAL
			STOS .08
			SPEC?
				JMP LamW_NaN2
			x=0?
				JMP LamW_exit
			Num eE
			1/x
			+/-
			x[<->] Y
			x<? Y
				JMP LamW_NaN
			STO .00
			LN1+x
LamW0_loop::		FILL
			+/-
			e[^x]
			RCL[times] .00
			-
			x[<->] Y
			INC X
			/
			-
			x[approx]? Y
			JMP LamW_exit
			JMP LamW0_loop

/**************************************************************************/
/* The negative branch of the real W function.
 *
 * MORE - needs conversion to double precision.
 */

		XLBL"W1"
			INTM?
				ERR ERR_BAD_MODE
			XLOCAL
			STOS .08
			SPEC?
				JMP LamW_NaN2
			x[>=]0?
				JMP LamW_inf
			STOS .08
			+/-
			1/x
			STO .00
			Num eE
			x>? Y
				JMP LamW_NaN
			RCL .00
LamW1_loop::		STO .01
			LN
			RCL[times] .00
			RCL .01
			x[<->] Y
			-
			x=0?
				JMP LamW_converged
			RCL L
			JMP LamW1_loop
LamW_converged::	RCL L
			RCL/ .00
			+/-
			JMP LamW_exit

LamW_inf::	x>0?
			JMP LamW_NaN2
		FC? D
			ERR ERR_MINFINITY
		Num -[infinity]
		JMP LamW_exit

LamW_NaN::	RCLS .08
LamW_NaN2::	FC? D
			ERR ERR_DOMAIN
		Num NaN

LamW_exit::	x[<->] .08
		STO L
		RCLS .08
		RTN


/**************************************************************************/
/* The positive branch of the complex W function.
 * A rough guess is made and then Newton's method is used to attain
 * convergence.  The C version works similarily but uses Halley's
 * method which converges a cubically instead of quadratically.
 *
 * MORE - needs to be written.
 */
		XLBL"CPX_W0"

/**************************************************************************/
/* The inverse W function in both real and complex domains.
 * These can be done inline without the usual prelude and epilogue code.
 *
 * MORE -- check these are shorter than using the prelude/epilogue.
 */

		XLBL"W_INVERSE"
		       DBLON
		       e[^x]
		       x[<->] L
		       RCL[times] L
		       DBLOFF
		       RTN

		/* MORE - this doesn't work in DBL mode for some reason */
		XLBL"CPX_W_INVERSE"
		       /* DBLON */
		       [cmplx]e[^x]
		       [cmplx]x[<->] L
		       [cmplx]RCL[times] L
		       /* DBLOFF */
		       RTN
