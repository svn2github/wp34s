/* This file is part of 34S.
 * 
 * 34S is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * 34S is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with 34S.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifdef INCLUDE_XROM_BESSEL
/**************************************************************************/
/* First order real argument Bessel functions Jn and In.
 * We just move into the complex argument and order and call the complex
 * equivalents.
 *
 * MORE: make this work natively for reals and integer order.
 */
			XLBL"BES_IN"
				xIN DYADIC
				LocR 11
				SF .01
				JMP bessel1_entry

			XLBL"BES_JN"
				xIN DYADIC
				LocR 11
bessel1_entry::			GSB bessel_fix_zeros
				GSB cpx_bessel1_entry
				xOUT xOUT_NORMAL

/**************************************************************************/
/* Second order real argument Bessel functions Yn and Kn.
 * We just move into the complex argument and order and call the complex
 * equivalents.
 *
 * MORE: make this work natively for reals and integer order.
 */
			XLBL"BES_KN"
				xIN DYADIC
				LocR 15
				SF .01
				JMP bessel2_entry

			XLBL"BES_YN"
				xIN DYADIC
				LocR 15
bessel2_entry::			GSB bessel_fix_zeros
				JMP cpx_bessel2_entry

bessel_fix_zeros::		Num 0
				STO T
				SWAP
				RTN



/**************************************************************************/
/* First order complex argument and order Bessel functions Jn and In.
 *
 * This code is based on Jean-Marc Baillard's HP-41 version from:
 *	http://hp41programs.yolasite.com/bessel.php
 *
 * MORE: make this work natively for large arguments and perhaps integer order.
 */
			XLBL"CPX_IN"
				xIN DYADIC_COMPLEX
				LocR 11
				SF .01
				GSB cpx_bessel1_entry
				xOUT xOUT_NORMAL

			XLBL"CPX_JN"
				xIN DYADIC_COMPLEX
				LocR 11
				GSB cpx_bessel1_entry
				xOUT xOUT_NORMAL

cpx_bessel1_entry::		[cmplx]STO .01
				CSWAP
				[cmplx]STO .05
				_INT 2
				STO/ .01
				STO/ .02
				[cmplx]RCL .01
				[cmplx]RCL[times] X
				[cmplx]STO .09
				[cmplx]Num 1
				STO .00
				[cmplx]STO .03
				[cmplx]STO .07
cpx_bessel1_loop::		[cmplx]RCL .09
				[cmplx]RCL[times] .03
				RCL .00
				FC? .01
					+/-
				STO/ Z
				/
				[cmplx]RCL .05
				RCL+ .00
				[cmplx]/
				[cmplx]STO .03
				[cmplx]RCL+ .07
				[cmplx]x[<->] .07
				[cmplx]RCL .07
				INC .00
				CNVG? CVG_COMPLEX
					JMP cpx_bessel1_fin
				JMP cpx_bessel1_loop
cpx_bessel1_fin::		[cmplx]RCL .01
				[cmplx]RCL .05
				[cmplx]y[^x]
				[cmplx][times]
				[cmplx]RCL .05
				INC X
				[cmplx][GAMMA]
				[cmplx]/
				RTN


/**************************************************************************/
/* Second order real argument Bessel functions Yn and Kn.
 *
 * This code is based on Jean-Marc Baillard's HP-41 version from:
 *	http://hp41programs.yolasite.com/bessel.php
 *
 * MORE: make this work natively for reals and integer order.
 */
			XLBL"CPX_KN"
				xIN DYADIC_COMPLEX
				LocR 15
				SF .01
				JMP cpx_bessel2_entry

			XLBL"CPX_YN"
				xIN DYADIC_COMPLEX
				LocR 15

cpx_bessel2_entry::		[cmplx]STO .11
				CSWAP
				INT?
					JMP cpx_bessel2_int_check
	    			CSWAP
cpx_bessel2_notint::		GSB cpx_bessel1_entry
				FS? .01
					JMP cpx_bessel2_kn_skip
				[cmplx]Num [pi]
				[cmplx]RCL[times] .05
				[cmplx]COS
				[cmplx][times]
cpx_bessel2_kn_skip::		[cmplx]STO .13
				[cmplx]RCL .05
				[cmplx]+/-
				[cmplx]RCL .11
				GSB cpx_bessel1_entry
				[cmplx]STO- .13
				[cmplx]Num [pi]
				[cmplx]RCL[times] .05
				[cmplx]SIN
				[cmplx]STO/ .13
				FS? .01
					JMP cpx_bessel2_2pi
				[cmplx]Num 1
				+/-
				JMP cpx_bessel2_skip
cpx_bessel2_2pi::		[cmplx]Num [pi]
				_INT 2
				/
cpx_bessel2_skip::		[cmplx]RCL[times] .13
				xOUT xOUT_NORMAL

cpx_bessel2_int_check::		SWAP
				x=0?
					JMP cpx_bessel2_int
				[<->] ZTYX
				JMP cpx_bessel2_notint
cpx_bessel2_int::		[<->] ZTYX
				ERR ERR_DOMAIN
#if 0
				GSB cpx_bessel1_entry
				[cmplx]STO .01
				_INT 2
				STO/ .11
				STO/ .12
				[cmplx]RCL .11
				[cmplx]LN
				Num 1
				FS? .01
					+/-
				STO .00
#endif

#endif
