/* This file is part of 34S.
 * 
 * 34S is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * 34S is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with 34S.  If not, see <http://www.gnu.org/licenses/>.
 */


/**************************************************************************/
/* Student's T distribution
 * One parameter:
 *	J = degrees of freedom (real > 0)
 */
		XLBL"PDF_T"
			xIN MONADIC
			GSB t_param
			FS?C .00
				JMP pdf_q_xout
			GSB pdf_t
			xOUT xOUT_NORMAL

pdf_t::			x[^2]		// x^2 ? ? ?
			Num 1/2
			RCL[times] J	// v/2 x^2 ? ?
			LN[GAMMA]	// LnG x^2 ? ?
			Num 1/2
			RCL+ L		// (v+1)/2 LnG x^2 ?
			STO I		// (v+1)/2 LnG x^2 ?
			LN[GAMMA]	// LnG2 LnG x^2 ?
			SWAP
			-		// LnG2-LnG x^2 ? ?
			x[<->] Y	// x^2 LnG2-LnG ? ?
			RCL/ J		// x^2/v LnG2-LnG ? ?
			LN1+x
			RCL[times] I	//[times]		// LN1+* LnG2-LnG ?
			-
			e[^x]
			Num [pi]
			RCL[times] J
			[sqrt]
			/
			RTN

#ifdef INCLUDE_CDFU
		XLBL"CDFU_T"
			xIN MONADIC
			+/-
			JMP cdf_t_common
#endif

		XLBL"CDF_T"
			xIN MONADIC
cdf_t_common::		GSB t_param
			FS?C .00
				JMP cdf_q_xout
			GSB cdf_t
			xOUT xOUT_NORMAL

cdfu_t::		+/-
cdf_t::			[infinity]?
				JMP cdf_t_infinite
			x=0?
				JMP dist_ret_half
			x>0?
				JMP cdf_t_invert
cdf_t_return::		RCL J		// v x ? ?
			SWAP		// x v ? ?
			x[^2]		// x^2 v ? ?
			RCL+ J		// v+x^2 v ? ?
			/		// v/(v+x^2) ? ? ?
			Num 1/2
			Num 1/2
			RCL[times] J	// v/2 .5 v/(v+x^2) ?
			[<->] ZXYT	// v/(v+x^2) v/2 .5 ?
			I[sub-x]
			Num 1/2
			[times]
			RTN

cdf_t_invert::		GSB cdf_t_return
			_INT 1
			SWAP
			-
			RTN

cdf_t_infinite::	x<0?
				JMP dist_ret_0
			JMP dist_ret_1

dist_ret_half::		Num 1/2
			RTN


		XLBL"QF_T"		// T Quantile Function
			xIN MONADIC
			GSB t_param
			GSB qf_check_probability
			FS?C .00
				JMP qf_q_xout
			LocR 002
			ENTER[^]	// probability in X, degrees of freedom in register J
			+/-		// -p p
			INC X		// 1-p p
			MIN
			x!=? L
			    SF .00	// set flag 00 if p > 0.5
			STO .00		// save p in R00
			_INT 5
			STO .01		// do not more than 5 iterations
			_INT 12
			RCL J
			+/-
			y^x
			RCL .00
			x>? Y
				JMP qf_t_low_est
			RCL J		// estimate for small p
			STO+ X
			[times]
			Num [pi]
			RCL L
			Num 1/2
			x[^2]
			RCL+ L		// = 0.75
			-
			/
			[sqrt]
			[times]
			RCL J
			XROOT
			RCL J
			[sqrt]
			x[<->] Y
			/
			JMP qf_q_loop

					// estimate for low and moderate t
qf_t_low_est::		XEQ qf_t_est	// get guess for the normal quantile
			x[^2]
			Num eE
			RCL[times] J
			1/x
			INC X
			[times]
			RCL/ J
			EXP-1
			RCL[times] J
			[sqrt]

qf_q_loop::		FILL		// iteration starts here
			Num 1/2		// 1/2 x x x
			x>? Y
			    JMP qf_q_Ix
			DROP		// x x x x
			GSB cdfu_t	// cdfu x x x
			RCL- .00	// cdfu-p x x x
			JMP qf_q_lp_com

qf_q_Ix::		DROP
			x[^2]		// x^2 x x x
			ENTER[^]
			RCL+ J		// n+x^2 x^2 x x
			/
			Num 1/2
			RCL[times] J	// n/2 x^2/(n+x^2) x x
			Num 1/2
			[<->] ZXYX	// x^2/(n+x^2) 1/2 n/2 1/2
			I[sub-x]	// Ix 1/2 x x
			[times]
			+/-
			Num 1/2
			RCL- .00
			+		// cdf(t) - p = (0,5-p) - 1/2 IBeta(x=t^2/(n+t^2), a=1/2, b=n/2)

qf_q_lp_com::		RCL Y		// x cdfu-p x x x
			GSB pdf_t	// pdf cdfu-p x x x
			/		// cdfu/pdf x x x
			ENTER[^]	// cdfu/pdf cdfu/pdf x x
			RCL[times] T	// x.cdfu/pdf cdfu/pdf x x
			RCL J		// n x.cdfu/pdf cdfu/pdf x
			INC X
			[times]		// (n+1).x.cdfu/pdf cdfu/pdf x x
			RCL T
			x[^2]		// x^2 (n+1).x.cdfu/pdf cdfu/pdf x
			RCL+ J
			STO+ X
			/
			DEC X
			/
			-
			CNVG? 00
				JMP qf_q_converged
			DSE .01
				JMP qf_q_loop
				// Raise error flag if no convergence after 5 iterations
			ERR 20  // if error, display "no root found" and exit with last approximation

qf_q_converged::	FS?C .00
				+/-	// adjust sign
			xOUT xOUT_NORMAL

// This normal estimate code should more to normal.wp34s and be unified with
// the code over there.
			// input: p =< 0.5
qf_t_est::		_INT 232	// output: Normal estimate > 0
			SDR 003
			x[<->] Y
			x>? Y
				JMP qf_q_mid_est
			FILL	    // Normal estimate for p up to 0.232
			LN		// ln p p p
			STO+ X		// 2ln p p p
			+/-		// -2ln p p p
			ENTER[^]	// -2ln -2ln p p
			DEC X		// -2ln-1 -2ln p p
			Num [pi]	// pi -2ln-1 -2ln p
			[times]		// pi(-2ln-1) -2ln p p
			STO+ X		// 2pi(-2ln-1) -2ln p p
			[sqrt]		// sqrt -2ln p p
			RCL[times] T
			LN
			STO+ X
			+/-
			[sqrt]
			x[<->] Y
			_INT 4
			[times]
			1/x
			+
			RTN

t_param::		RCL J
			[infinity]?
				JMP t_param_inf
			GSB check_special_pos
t_drop_rtn::		DROP
			RTN

t_param_inf::		x<0?
				ERR ERR_BAD_PARAM
			SF .00
			JMP t_drop_rtn

