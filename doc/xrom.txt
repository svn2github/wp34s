To convert a program into something suitable for inclusion in XROM is very easy.


As an example I'll show how to convert the Area of a Triangle via Heron's formula by Jean-Marc Baillard, the source code for which and description is available from http://hp41programs.yolasite.com/heron.php.


	01  LBL "HERON"		XLBL"HERON"
				xIN TRIADIC
				SSIZE4
	02  STO T		STO T
	03  RDN			R[v]
	04  ST+ Z		STO+ Z
	05  RDN			R[v]
	06  ST+ Y		STO+ Y
	07  X<>Y		x[<->] Y
	08  SIGN 		SIGN
	09  ST+ X		STO+ X
	10  ST/ L		STO/ L
	11  X<> L		x[<->] L
	12  ST- Y		STO- Y
	13  ST- Z		STO- Z
	14  ST- T		STO- T
	15  *			[times]
	16  *			[times]
	17  *			[times]
	18  CHS			+/-
	19  SQRT		[sqrt]
	20  END			xOUT xOUT_NORMAL


The important difference is the addition of the xIN and xOUT commands.


xIN does a lot:

* it generates an error if the device is in integer mode
* it specifies the number of input arguments (in this case 3)
* it specifies the number of output arguments (in this case 1)
* it flags if last x should be handled or not (in this case yes)
* it switches to double precision mode if required
* it allocates a temporary stack in volatile RAM
* it sets the stack size to 8 (thus we needs the SSIZE4 to go back to four levels)
* if local registers are allocated (via LocR), they are allocated in volatile RAM.
* all lettered registers are copied into the new work space, they aren't copied back and are freely available.



xOUT exits XROM.  It also does quite a bit:

* reverts to the previous stack size
* reverts to single precision mode if that was set when xIN was called
* exits any called subroutines immediately
* can optionally skip a statement on return to user code


The XLBL command doesn't generate any code, it provides an entry point that the C function tables can take advantage of.

There are only a couple of restrictions in xrom code.  There are no LBL statements.  Instead use JMP for branches and GSB for subroutine calls.  These get automatically converted to relative branches if possible and branches via a jump table otherwise.



Time for a second example.  Again from Jean-Marc Baillard, an implementation of the complex version of Lambert's W function.  The original is available from http://hp41programs.yolasite.com/lambertw.php  This version makes extensive use of the 34S's complex instructions.


				XLBL"CPX_W0"
				xIN MONADIC_COMPLEX
				LocR 06
				[cmplx]STO .00
				Num 1
				STO .02
				STO .03
				+
				[cmplx]x=0?
					JMP LamW_cloop
				[cmplx]LN
				[cmplx]STO .02
	LamW_cloop::		[cmplx]ENTER
				[cmplx]e[^x]
				[cmplx]STO .04
				[cmplx]RCL[times] .02
				[cmplx]STO+ .04
				[cmplx]RCL- .00
				[cmplx]RCL/ .04
				[cmplx]STO- .02
				[cmplx]DROP
				[cmplx]RCL .02
				CNVG? CVG_COMPLEX
					xOUT xOUT_NORMAL
				JMP LamW_cloop

Here, the xIN specifies a complex function of one argument and one result (both complex, occupying X and Y), again with last X being saved (which in this case is L and I since it is a complex function).  The LocR allocates local registers .00 through .05 and local flags .00 through .15.  The branches of the original program are replaced by JMP instructions that expand into a SKIP and a BACK instruction automatically.  The CNVG? test checks the loop termination condition and xOUT fixes the exit stack appropriately.

