<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title>WP 34S - Memory Management</title>


</head>


<body>

<h1>WP 34S Memory Management</h1>

<p>This
chapter discusses how memory is divided between the program area, local
and global data.</p>

<h2>Memory Layout </h2>

<p>The two kilobytes of non volatile RAM are divided in four
distinct areas:</p>

<ol>

  <li>Program Memory,</li>

  <li>The subroutine return stack,</li>

  <li>The registers used for cumulative statistics,</li>

  <li>The global registers, including the stack,</li>

  <li>Status and configuration data.</li>

</ol>

<p>The areas are arranged in the order noted above. This chapter
deals with information about the variable boundaries between these
areas.</p>

<p>A complete copy of the nonvolatile RAM can be written to flash
region <span style="font-family: monospace;">0</span>
with the Command <span style="font-family: monospace;">SAVE</span>
(<span style="font-family: Helvetica,Arial,sans-serif; font-weight: bold;">ON</span>+<span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;">STO</span>).
The document <a href="flash.txt">flash.txt</a> or
the manual have more information about the handling of flash memory.</p>

<h2>Program Data in RAM or Flash</h2>

<p>The block reserved for program data is one kilobyte in size.
This is exactly the size of a flash region. A step occupies two bytes,
the fields holding the current size and the checksum are two bytes wide
each. This translates to a maximum of 510 program steps. A program step
typically is just one physical step. The multi byte labels and multi
character alpha strings take two steps each.</p>

<p> The program area is followed by the subroutine return stack.
Unused program steps can be taken over by return addresses and local
data. There is no command to set the size. The boundary between the
return stack and the program data is determined by the number of steps
currently stored.&nbsp;When new program steps are entered, the
subroutine return stack is reset to make room. There are situations
where this will not return programm memory to the full size: The
summation registers may have taken their share (see below).<br>

</p>

<h2>Global Registers</h2>

<p>Global registers are placed near the end of available memory.
The numberered registers <span style="font-family: monospace;">00</span>
to <span style="font-family: monospace;">99</span>
precede the stack and special registers <span style="font-family: monospace;">X</span>, <span style="font-family: monospace;">Y</span>, <span style="font-family: monospace;">Z</span>, <span style="font-family: monospace;">T</span>, <span style="font-family: monospace;">A</span>, <span style="font-family: monospace;">B</span>, <span style="font-family: monospace;">C</span>, <span style="font-family: monospace;">D</span>, <span style="font-family: monospace;">L</span>, <span style="font-family: monospace;">I</span>, <span style="font-family: monospace;">J</span> and <span style="font-family: monospace;">K</span>. This totals
to 112 registers, each occupying eight bytes (or 4 steps). For programs
which do not need all the numbered registers the amount can be reduced
by specifying the highest numbered register with the command <span style="font-family: monospace;">REGS nn</span>. With <span style="font-family: monospace;">REGS 99</span> you get
the default state, <span style="font-family: monospace;">REGS
00</span> just leaves a single numbered register for use. You can
query the current allocation with <span style="font-family: monospace;">REGS?</span>.</p>

<p>What happens when <span style="font-family: monospace;">REGS</span>
is executed is that the beginning of the register area is moved. When
the new upper limit is lower then it was, the move goes towards higher
addresses; increasing the number of registers will move the boundary
towards lower adresses. The memory contents is moved, too, thus
preserving the register data for the remaining registers. The lettered
registers stay in their place. As an example, after <span style="font-family: monospace;">REGS 89</span>,
register <span style="font-family: monospace;">89</span><span style="font-family: monospace;"></span> is followed
directly by register&nbsp;<span style="font-family: monospace;"></span><span style="font-family: monospace;">X</span><span style="font-family: monospace;"></span>. If the
previous allocation was <span style="font-family: monospace;">REGS
99</span>, registers <span style="font-family: monospace;">90</span>
to <span style="font-family: monospace;">99</span>
are lost. The memory location of register <span style="font-family: monospace;">00</span> is where
register <span style="font-family: monospace;">10</span>
used to be. The indirect indexes change accordingly so that register <span style="font-family: monospace;">00</span> is always
addressed by a zero in&nbsp; the index register, regardless of
memory allocation. In the example above, index values <span style="font-family: monospace;">90</span> to <span style="font-family: monospace;">99</span> become
invalid and will throw a range error.</p>

<p>The space gained is added to the return stack. It may be
necessary to reduce the number of global registers before using <span style="font-family: monospace;">[Sigma]+</span>
because the summation registers reside outside the numbered register
set (see below). Since the return stack and the summation data are tied
to the boundary just moved, they are copied into their new location
together with the register data. This makes it possible to execute <span style="font-family: monospace;">REGS</span> in the
middle of a subroutine without disrupting the program.</p>

<h2>Local Registers and Flags</h2>

<p>Being able to store private data without worrying about
overwriting the user's resources adds greatly to the flexibility of a
program. This is accomplished by using the subroutine return stack to
store not only return adresses but also local registers and flags.
Before you can use the feature, you may have to make room.</p>

<h3><a name="How_to_Make_Room"></a>How to Make Room</h3>

<p>The total size of the return stack is given by the following
equation:</p>

<p># of steps = free program memory + fixed stack size + memory
freed by REGS command - memory used by summation data.</p>

<p>With 100 fixed registers and a full program area, you will get
about 20 return levels. In this configuration it is impossible to
allocate the summation registers. You have several options to increase
the available space:</p>

<ol>

  <li>Reduce the number of fixed registers. Each register is
worth four steps (or levels).</li>

  <li>Move the programm to a flash region and clear the program
in RAM.</li>

</ol>

Which solution suites you best depends on the application. You may of
course do both. Use <span style="font-family: monospace;">MEM?</span>
to query the free space in steps.
<h3>Commands involved<br>

</h3>

<p><span style="font-family: monospace;">LOCL
nn&nbsp;</span>- Reserve <span style="font-family: monospace;">nn</span>+1 local
registers and 16 local flags.<br>

<span style="font-family: monospace;">LPOP&nbsp;&nbsp;&nbsp;
-</span> Pop the local registers without returning.<br>

<span style="font-family: monospace;">RTN&nbsp;&nbsp;&nbsp;
&nbsp;</span>- Pop the local registers and return.<br>

<span style="font-family: monospace;">LOCL?&nbsp;&nbsp;&nbsp;</span>-
How many local registers are allocated?<br>

<span style="font-family: monospace;">MEM?&nbsp;&nbsp;&nbsp;&nbsp;</span>-
How much memory (in steps) is left?</p>

<p>There are no special commands to access the local data, just
the
regular register and flag operations with a modified address part.<br>

</p>

<h3>Addressing</h3>

<p>Local registers and flags are addressed with a dot before the
number, from <span style="font-family: monospace;">.00</span>
to <span style="font-family: monospace;">.15</span>.
The highest possible direct address is <span style="font-family: monospace;">.15</span>, due to a
technical limit. Higher numbered registers can be used by indirect
addressing only. The maximum value for <span style="font-family: monospace;">nn</span> is <span style="font-family: monospace;">99</span>, giving 100
local registers. Local flags are always allocated from <span style="font-family: monospace;">.00</span> to <span style="font-family: monospace;">.15</span>, regardless
of the argument given to <span style="font-family: monospace;">LOCL</span>.</p>

<p>Indirect addresses go from <span style="font-family: monospace;">112</span>
(a magic number) to <span style="font-family: monospace;">211</span>
(magically a palindrome, in fact just <span style="font-family: monospace;">112+100-1</span>). The
directly addressable registers and the flags range from <span style="font-family: monospace;">112</span> to <span style="font-family: monospace;">127</span>. (<span style="font-family: monospace;">127</span> is the
highest argument that can be stored in an op-code, hence the limit.) An
easier to remember alternate addressing scheme uses negative indexes
but this way <span style="font-family: monospace;">.00</span>
cannot be accessed and this will not work for any unsigned integer
mode. It's just an alternative for those who don't like the magic value
<span style="font-family: monospace;">112</span>.
Flags and registers are addressed with the exact same index values.</p>

<p>This scheme makes it possible to address a global register
with a local
index register (<span style="font-family: monospace;">STO-&gt;.00</span>
with a value below <span style="font-family: monospace;">112</span>
in <span style="font-family: monospace;">.00</span>),
a local register with a global index register (<span style="font-family: monospace;">STO-&gt;00</span>
with an index from <span style="font-family: monospace;">112</span>
onwards), or a local register with a local index register.<br>

</p>

<h3>Allocation and Visibility<br>

</h3>

<p>After executing <span style="font-family: monospace;">LOCL</span>,
a frame is allocated on the return stack which contains:<br>

</p>

<ol>

  <li>A&nbsp;marker,</li>

  <li>A&nbsp;flag word,</li>

  <li>The register data (4 steps per register).</li>

</ol>

<p>A pointer in memory is initialized to point to this frame. If
the pointer is zero, no local registers exist. The number of registers
(actually the size of the frame in steps) is encoded in the marker. The
flag word is sometimes allocated at the end of the frame instead of its
start to ensure a 32 bit alignment of the register data. This is
handled transparently. Newly allocated registers are cleared to zero.</p>

<p>Executing <span style="font-family: monospace;">LOCL</span>
again from the same subroutine level will adjust the number of
registers. This requires data copying because the registers are
allocated from low to high addresses and the stack grows in the
opposite direction. If the number of registers increases, the new
registers a zeroed.</p>

<p><span style="font-family: monospace;">LOCL?</span>
will give you the number of local registers available.</p>

<p><span style="font-family: monospace;">XEQ</span>
in a program does not do anything special, it just pushes the return
address before it branches to the target. This means, that a subroutine
that does not execute a <span style="font-family: monospace;">LOCL</span>
command itself will have access to the caller's local registers. Once <span style="font-family: monospace;">LOCL</span> is
executed by the callee, the caller's local registers are hidden from
view.</p>

<p>RTN or LPOP in a program check if the current stack pointer
points to a local frame. If that's the case the stack pointer is moved
above the frame where the return address is found and the rest of the
stack is searched upwards for another local frame. If one is found its
pointer is stored, else the pointer is cleared. RTN will pop and branch
to the return address while LPOP will just continue execution.</p>

<p>Manually executing RTN, starting a new program with XEQ, or
program editing will clear the return stack and remove any local data
by clearing the pointer. Any register contents in any local register or
flag is lost!</p>

<h3>Recursive Programming</h3>

<p>Using local registers makes it possible to create a subroutine that
calls itself recursively, each invocation dealing with its local data
only. Of course the RPN stack is global so you need be careful not to
corrupt it.</p>
<p> Here is a recursive implementation of the factorial (not setting LastX correctly):</p>
<pre>	LBL'FAC'<br>	IP<br>	x&gt;1?<br>	SKIP 02<br>	1<br>	RTN<br>	LOCL 00<br>	STO .00<br>	DEC X<br>	XEQ'FAC'<br>	RCL[times] .00<br>	RTN</pre>

<h2>Cumulative Statistics</h2>

<p>The summation registers for the cumulative statistics are no longer
held in the user register space but are allocated seperately. This
offers the opportunity to&nbsp; deal with higher internal precision and
avoids clobbering&nbsp;their contents manually. The only way to set the
registers is with the <span style="font-family: monospace;">[Sigma]+</span> and <span style="font-family: monospace;">[Sigma]-</span> commands. They can be queried with their respective dedicated comands only, not by <span style="font-family: monospace;">RCL</span>.</p>

<p>The first invocation of <span style="font-family: monospace;">[Sigma]+</span> allocates the required space just below register <span style="font-family: monospace;">00</span> and above the subroutine return stack, pushing it down in memory. It may be necessary <a href="#How_to_Make_Room">to make room</a> first. At present 54&nbsp; steps are required for the data.&nbsp; When the number of data points reaches zero, either by <span style="font-family: monospace;">[Sigma]-</span> or by <span style="font-family: monospace;">CL[Sigma]</span>,
the block is deallocated again. All pointers are
automatically&nbsp;adjusted so that this allocation or deallocation
does not disrupt a running program.</p>
<p>When memory allocation fails, an error is thrown. Most functions
will throw an error if not enough data points have been entered. The
register query commands such as <span style="font-family: monospace;">[Sigma]n</span> return zero if no data is allocated. </p>
</body>
</html>
