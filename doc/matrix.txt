There are a number of built in matrix related commands.  These are
designed to provide the low level support routines for creating
more useful matrix functions as key stroke programs.  I.e. they
correspond to the BLAS of the 34S's matrix support.

All these routines take or create a matrix descriptor.  This is a
real number in the format:

	bb.ccrr

where:
	bb is the base register (00 - 99).

	cc is the number of columns in the matrix (01 - 99).

	rr is the number of rows in the matrix (01 - 99).  If rr
		is omitted, the value of cc is used and the matrix
		is assumed to be square.



The commands:

M.TRN - matrix transpose.

	Takes a matrix descriptor in X (in the bb.ccrr format) and
	returns the descriptor for the transpose of X (bb.rrcc).
	The transpose is done in-situ and doesn't require any
	additional registers or storage.  This is kind of fiddly
	when done in RPN.


M.[times] - matrix multiply

	Takes matrix descriptors in Y and Z and the integer part
	of X as the base of the result.  It calculates X = Z * Y.
	The fraction portion of X is updated to match the resulting
	matrix and no overlap checking is performed.  All calculations
	are done internally in high precision, although it would
	still be possible to trick the code up and produce bad
	results.  It would be very difficult to get the same degree
	of accuracy in RPN since the best that can easily be achieves
	there is a*b+c*d and a matrix multiply adds more terms than
	this.


M.+[times] - generalised matrix addition.

	Takes a real in z and matrix descriptors in Y and X.
	Calculates X = X + z * Y.  That is a scalar multiple of a
	matrix is added to another matrix.  Again the multiply adds
	are done in extended precision and results should be exactly
	rounded.  This one would be possible in RPN without losing
	accuracy but again, fiddly.

M.R[<->]  (similar to PPC M1).			Optional: MATRIX_ROWOPS

	Takes a matrix descriptor in X, and two row numbers in Y
	and Z.  It swaps those two rows in the matrix.  The stack
	is unmodified.


M.R[times]   (similar to PPC M2).		Optional: MATRIX_ROWOPS

	Takes a matrix descriptor in X, a row number in Y and a
	constant in z.  It multiplies the specified row of the
	matrix by z.  The stack is unmodified.


M.R+[times]   (similar to PPC M3).		Optional: MATRIX_ROWOPS

	Takes a matrix descriptor in X, a destination row number
	in Y, a source row number in Z and a constant in t.  It
	multiples the contents of row Z by t and adds these to row
	Y.  i.e. X[*:Y] = X[*:Y] + t * X[*:Z].  The stack is
	unchanged.


M.IJ   (similar to PPC M4).

	Takes a matrix descriptor in X and a register number in Y.
	Returns the column that register represents in Y and the
	row in X.  The matrix descriptor is saved in last X.


M.REG   (similar to PPC M5).

	Takes a matrix descriptor in X, a row number in Y and a
	column number in Z.  Returns the register index in X (popping
	the stack twice).  The matrix descriptor is saved in last
	X.

M.ALL
	Takes a matrix descriptor in X and returns a value suitable
	for ISG or DSL looping in X (and sets last X like all good
	commands).  The loop processes all elements in the matrix.
	The loop index is DSL if the descriptor is negative and ISG
	for positive.

M.ROW
	Takes a matrix descriptor in X and a row number in Y.  It
	returns a value suitable for looping in X (dropping the
	stack and setting last x like all two argument commands).
	The loop process all elements in the specified row only.
	The loop index is DSL if the descriptor is negative and ISG
	for positive.

M.COL
	Takes a matrix descriptor in X and a column number in Y.
	It returns a value suitable for looping in X (again acting
	like a two argument command).  The loop processes all
	elements in the specified column only.  The loop index is
	DSL if the descriptor is negative and ISG for positive.

M.ROW?
	Takes a matrix descriptor in X and returns the number of
	rows in the matrix.  The descriptor is saved in LastX.

M.COL?
	Takes a matrix descriptor in X and returns the number of
	columns in the matrix.  The descritpor is saved in LastX.

M.SQR?
	Takes a matrix descriptor in X and generates an error if
	it isn't square.  Does nothing if it is.

M.IDEN						Optional: SILLY_MATRIX_SUPPORT
	Takes a matrix descriptor for a square matrix in X and fills
	the corresponding registers so that it is an identity matrix.

M.ZERO						Optional: SILLY_MATRIX_SUPPORT
	Takes a matrix descriptor in X and zeros the registers
	corresponding to the matrix.  The stack remains unchanged.


M.DET
	Take a matrix descriptor in X and return the determinant
	of the matrix.  The matrix must be square and is not modified.

M.LU						Optional: MATRIX_LU_DECOMP
	Take a matrix descriptor in X modify the matrix into its
	LU decomposition.  The matrix must be square and it is
	modified in-situ.  The value in X is replaced by a pivot
	descriptor that defines the pivots that were required to
	calculate the decomposition.  The most significant digit
	is the pivot for the first diagonal entry, the next most
	the second and so forth.


Errors:

	"Out of Range" is a matrix descriptor would go beyond the
		registers available or a row or column index is too
		large or negative.

	"Bad Parameter" if the number of columns is zero.

	"Matrix Dimension" if a matrix isn't square when it should
		be or matrix sizes aren't miscable.

	"Singular Error" if a matrix is LU decomposed, used to solve
		a system of equations or is inverted when it isn't
		of full rank.
